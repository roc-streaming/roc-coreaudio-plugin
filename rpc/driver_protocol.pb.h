// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: driver_protocol.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_driver_5fprotocol_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_driver_5fprotocol_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_driver_5fprotocol_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_driver_5fprotocol_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_driver_5fprotocol_2eproto;
namespace rocvad {
class PrDeviceInfo;
struct PrDeviceInfoDefaultTypeInternal;
extern PrDeviceInfoDefaultTypeInternal _PrDeviceInfo_default_instance_;
class PrDeviceList;
struct PrDeviceListDefaultTypeInternal;
extern PrDeviceListDefaultTypeInternal _PrDeviceList_default_instance_;
class PrDeviceSelector;
struct PrDeviceSelectorDefaultTypeInternal;
extern PrDeviceSelectorDefaultTypeInternal _PrDeviceSelector_default_instance_;
class PrDriverInfo;
struct PrDriverInfoDefaultTypeInternal;
extern PrDriverInfoDefaultTypeInternal _PrDriverInfo_default_instance_;
class PrEndpointInfo;
struct PrEndpointInfoDefaultTypeInternal;
extern PrEndpointInfoDefaultTypeInternal _PrEndpointInfo_default_instance_;
class PrEndpointRequest;
struct PrEndpointRequestDefaultTypeInternal;
extern PrEndpointRequestDefaultTypeInternal _PrEndpointRequest_default_instance_;
class PrLocalConfig;
struct PrLocalConfigDefaultTypeInternal;
extern PrLocalConfigDefaultTypeInternal _PrLocalConfig_default_instance_;
class PrLogEntry;
struct PrLogEntryDefaultTypeInternal;
extern PrLogEntryDefaultTypeInternal _PrLogEntry_default_instance_;
class PrNone;
struct PrNoneDefaultTypeInternal;
extern PrNoneDefaultTypeInternal _PrNone_default_instance_;
class PrReceiverConfig;
struct PrReceiverConfigDefaultTypeInternal;
extern PrReceiverConfigDefaultTypeInternal _PrReceiverConfig_default_instance_;
class PrSenderConfig;
struct PrSenderConfigDefaultTypeInternal;
extern PrSenderConfigDefaultTypeInternal _PrSenderConfig_default_instance_;
}  // namespace rocvad
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace rocvad {
enum PrLogEntry_Level : int {
  PrLogEntry_Level_CRIT = 0,
  PrLogEntry_Level_ERROR = 1,
  PrLogEntry_Level_WARN = 2,
  PrLogEntry_Level_INFO = 3,
  PrLogEntry_Level_DEBUG = 4,
  PrLogEntry_Level_TRACE = 5,
  PrLogEntry_Level_PrLogEntry_Level_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrLogEntry_Level_PrLogEntry_Level_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrLogEntry_Level_IsValid(int value);
extern const uint32_t PrLogEntry_Level_internal_data_[];
constexpr PrLogEntry_Level PrLogEntry_Level_Level_MIN = static_cast<PrLogEntry_Level>(0);
constexpr PrLogEntry_Level PrLogEntry_Level_Level_MAX = static_cast<PrLogEntry_Level>(5);
constexpr int PrLogEntry_Level_Level_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
PrLogEntry_Level_descriptor();
template <typename T>
const std::string& PrLogEntry_Level_Name(T value) {
  static_assert(std::is_same<T, PrLogEntry_Level>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Level_Name().");
  return PrLogEntry_Level_Name(static_cast<PrLogEntry_Level>(value));
}
template <>
inline const std::string& PrLogEntry_Level_Name(PrLogEntry_Level value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrLogEntry_Level_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool PrLogEntry_Level_Parse(absl::string_view name, PrLogEntry_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrLogEntry_Level>(
      PrLogEntry_Level_descriptor(), name, value);
}
enum PrDeviceType : int {
  PR_DEVICE_TYPE_SENDER = 0,
  PR_DEVICE_TYPE_RECEIVER = 1,
  PrDeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrDeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrDeviceType_IsValid(int value);
extern const uint32_t PrDeviceType_internal_data_[];
constexpr PrDeviceType PrDeviceType_MIN = static_cast<PrDeviceType>(0);
constexpr PrDeviceType PrDeviceType_MAX = static_cast<PrDeviceType>(1);
constexpr int PrDeviceType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
PrDeviceType_descriptor();
template <typename T>
const std::string& PrDeviceType_Name(T value) {
  static_assert(std::is_same<T, PrDeviceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrDeviceType_Name().");
  return PrDeviceType_Name(static_cast<PrDeviceType>(value));
}
template <>
inline const std::string& PrDeviceType_Name(PrDeviceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrDeviceType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PrDeviceType_Parse(absl::string_view name, PrDeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrDeviceType>(
      PrDeviceType_descriptor(), name, value);
}
enum PrInterface : int {
  PR_INTERFACE_CONSOLIDATED = 0,
  PR_INTERFACE_AUDIO_SOURCE = 1,
  PR_INTERFACE_AUDIO_REPAIR = 2,
  PR_INTERFACE_AUDIO_CONTROL = 3,
  PrInterface_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrInterface_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrInterface_IsValid(int value);
extern const uint32_t PrInterface_internal_data_[];
constexpr PrInterface PrInterface_MIN = static_cast<PrInterface>(0);
constexpr PrInterface PrInterface_MAX = static_cast<PrInterface>(3);
constexpr int PrInterface_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
PrInterface_descriptor();
template <typename T>
const std::string& PrInterface_Name(T value) {
  static_assert(std::is_same<T, PrInterface>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrInterface_Name().");
  return PrInterface_Name(static_cast<PrInterface>(value));
}
template <>
inline const std::string& PrInterface_Name(PrInterface value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrInterface_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool PrInterface_Parse(absl::string_view name, PrInterface* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrInterface>(
      PrInterface_descriptor(), name, value);
}
enum PrChannelLayout : int {
  PR_CHANNEL_LAYOUT_MONO = 0,
  PR_CHANNEL_LAYOUT_STEREO = 1,
  PrChannelLayout_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrChannelLayout_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrChannelLayout_IsValid(int value);
extern const uint32_t PrChannelLayout_internal_data_[];
constexpr PrChannelLayout PrChannelLayout_MIN = static_cast<PrChannelLayout>(0);
constexpr PrChannelLayout PrChannelLayout_MAX = static_cast<PrChannelLayout>(1);
constexpr int PrChannelLayout_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
PrChannelLayout_descriptor();
template <typename T>
const std::string& PrChannelLayout_Name(T value) {
  static_assert(std::is_same<T, PrChannelLayout>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrChannelLayout_Name().");
  return PrChannelLayout_Name(static_cast<PrChannelLayout>(value));
}
template <>
inline const std::string& PrChannelLayout_Name(PrChannelLayout value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrChannelLayout_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PrChannelLayout_Parse(absl::string_view name, PrChannelLayout* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrChannelLayout>(
      PrChannelLayout_descriptor(), name, value);
}
enum PrPacketEncoding : int {
  PR_PACKET_ENCODING_AVP_L16_MONO = 0,
  PR_PACKET_ENCODING_AVP_L16_STEREO = 1,
  PrPacketEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrPacketEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrPacketEncoding_IsValid(int value);
extern const uint32_t PrPacketEncoding_internal_data_[];
constexpr PrPacketEncoding PrPacketEncoding_MIN = static_cast<PrPacketEncoding>(0);
constexpr PrPacketEncoding PrPacketEncoding_MAX = static_cast<PrPacketEncoding>(1);
constexpr int PrPacketEncoding_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
PrPacketEncoding_descriptor();
template <typename T>
const std::string& PrPacketEncoding_Name(T value) {
  static_assert(std::is_same<T, PrPacketEncoding>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrPacketEncoding_Name().");
  return PrPacketEncoding_Name(static_cast<PrPacketEncoding>(value));
}
template <>
inline const std::string& PrPacketEncoding_Name(PrPacketEncoding value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrPacketEncoding_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PrPacketEncoding_Parse(absl::string_view name, PrPacketEncoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrPacketEncoding>(
      PrPacketEncoding_descriptor(), name, value);
}
enum PrFecEncoding : int {
  PR_FEC_ENCODING_DISABLE = 0,
  PR_FEC_ENCODING_RS8M = 1,
  PR_FEC_ENCODING_LDPC_STAIRCASE = 2,
  PrFecEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrFecEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrFecEncoding_IsValid(int value);
extern const uint32_t PrFecEncoding_internal_data_[];
constexpr PrFecEncoding PrFecEncoding_MIN = static_cast<PrFecEncoding>(0);
constexpr PrFecEncoding PrFecEncoding_MAX = static_cast<PrFecEncoding>(2);
constexpr int PrFecEncoding_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
PrFecEncoding_descriptor();
template <typename T>
const std::string& PrFecEncoding_Name(T value) {
  static_assert(std::is_same<T, PrFecEncoding>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrFecEncoding_Name().");
  return PrFecEncoding_Name(static_cast<PrFecEncoding>(value));
}
template <>
inline const std::string& PrFecEncoding_Name(PrFecEncoding value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrFecEncoding_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool PrFecEncoding_Parse(absl::string_view name, PrFecEncoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrFecEncoding>(
      PrFecEncoding_descriptor(), name, value);
}
enum PrLatencyTunerBackend : int {
  PR_LATENCY_TUNER_BACKEND_DEFAULT = 0,
  PR_LATENCY_TUNER_BACKEND_NIQ = 2,
  PrLatencyTunerBackend_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrLatencyTunerBackend_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrLatencyTunerBackend_IsValid(int value);
extern const uint32_t PrLatencyTunerBackend_internal_data_[];
constexpr PrLatencyTunerBackend PrLatencyTunerBackend_MIN = static_cast<PrLatencyTunerBackend>(0);
constexpr PrLatencyTunerBackend PrLatencyTunerBackend_MAX = static_cast<PrLatencyTunerBackend>(2);
constexpr int PrLatencyTunerBackend_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
PrLatencyTunerBackend_descriptor();
template <typename T>
const std::string& PrLatencyTunerBackend_Name(T value) {
  static_assert(std::is_same<T, PrLatencyTunerBackend>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrLatencyTunerBackend_Name().");
  return PrLatencyTunerBackend_Name(static_cast<PrLatencyTunerBackend>(value));
}
template <>
inline const std::string& PrLatencyTunerBackend_Name(PrLatencyTunerBackend value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrLatencyTunerBackend_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool PrLatencyTunerBackend_Parse(absl::string_view name, PrLatencyTunerBackend* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrLatencyTunerBackend>(
      PrLatencyTunerBackend_descriptor(), name, value);
}
enum PrLatencyTunerProfile : int {
  PR_LATENCY_TUNER_PROFILE_DEFAULT = 0,
  PR_LATENCY_TUNER_PROFILE_INTACT = 1,
  PR_LATENCY_TUNER_PROFILE_RESPONSIVE = 2,
  PR_LATENCY_TUNER_PROFILE_GRADUAL = 3,
  PrLatencyTunerProfile_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrLatencyTunerProfile_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrLatencyTunerProfile_IsValid(int value);
extern const uint32_t PrLatencyTunerProfile_internal_data_[];
constexpr PrLatencyTunerProfile PrLatencyTunerProfile_MIN = static_cast<PrLatencyTunerProfile>(0);
constexpr PrLatencyTunerProfile PrLatencyTunerProfile_MAX = static_cast<PrLatencyTunerProfile>(3);
constexpr int PrLatencyTunerProfile_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
PrLatencyTunerProfile_descriptor();
template <typename T>
const std::string& PrLatencyTunerProfile_Name(T value) {
  static_assert(std::is_same<T, PrLatencyTunerProfile>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrLatencyTunerProfile_Name().");
  return PrLatencyTunerProfile_Name(static_cast<PrLatencyTunerProfile>(value));
}
template <>
inline const std::string& PrLatencyTunerProfile_Name(PrLatencyTunerProfile value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrLatencyTunerProfile_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool PrLatencyTunerProfile_Parse(absl::string_view name, PrLatencyTunerProfile* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrLatencyTunerProfile>(
      PrLatencyTunerProfile_descriptor(), name, value);
}
enum PrResamplerBackend : int {
  PR_RESAMPLER_BACKEND_DEFAULT = 0,
  PR_RESAMPLER_BACKEND_BUILTIN = 1,
  PR_RESAMPLER_BACKEND_SPEEX = 2,
  PR_RESAMPLER_BACKEND_SPEEXDEC = 3,
  PrResamplerBackend_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrResamplerBackend_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrResamplerBackend_IsValid(int value);
extern const uint32_t PrResamplerBackend_internal_data_[];
constexpr PrResamplerBackend PrResamplerBackend_MIN = static_cast<PrResamplerBackend>(0);
constexpr PrResamplerBackend PrResamplerBackend_MAX = static_cast<PrResamplerBackend>(3);
constexpr int PrResamplerBackend_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
PrResamplerBackend_descriptor();
template <typename T>
const std::string& PrResamplerBackend_Name(T value) {
  static_assert(std::is_same<T, PrResamplerBackend>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrResamplerBackend_Name().");
  return PrResamplerBackend_Name(static_cast<PrResamplerBackend>(value));
}
template <>
inline const std::string& PrResamplerBackend_Name(PrResamplerBackend value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrResamplerBackend_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool PrResamplerBackend_Parse(absl::string_view name, PrResamplerBackend* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrResamplerBackend>(
      PrResamplerBackend_descriptor(), name, value);
}
enum PrResamplerProfile : int {
  PR_RESAMPLER_PROFILE_DEFAULT = 0,
  PR_RESAMPLER_PROFILE_HIGH = 1,
  PR_RESAMPLER_PROFILE_MEDIUM = 2,
  PR_RESAMPLER_PROFILE_LOW = 3,
  PrResamplerProfile_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrResamplerProfile_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrResamplerProfile_IsValid(int value);
extern const uint32_t PrResamplerProfile_internal_data_[];
constexpr PrResamplerProfile PrResamplerProfile_MIN = static_cast<PrResamplerProfile>(0);
constexpr PrResamplerProfile PrResamplerProfile_MAX = static_cast<PrResamplerProfile>(3);
constexpr int PrResamplerProfile_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
PrResamplerProfile_descriptor();
template <typename T>
const std::string& PrResamplerProfile_Name(T value) {
  static_assert(std::is_same<T, PrResamplerProfile>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrResamplerProfile_Name().");
  return PrResamplerProfile_Name(static_cast<PrResamplerProfile>(value));
}
template <>
inline const std::string& PrResamplerProfile_Name(PrResamplerProfile value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrResamplerProfile_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool PrResamplerProfile_Parse(absl::string_view name, PrResamplerProfile* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrResamplerProfile>(
      PrResamplerProfile_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PrNone final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:rocvad.PrNone) */ {
 public:
  inline PrNone() : PrNone(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrNone(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrNone(const PrNone& from) : PrNone(nullptr, from) {}
  inline PrNone(PrNone&& from) noexcept
      : PrNone(nullptr, std::move(from)) {}
  inline PrNone& operator=(const PrNone& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrNone& operator=(PrNone&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrNone& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrNone* internal_default_instance() {
    return reinterpret_cast<const PrNone*>(
        &_PrNone_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(PrNone& a, PrNone& b) { a.Swap(&b); }
  inline void Swap(PrNone* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrNone* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrNone* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<PrNone>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PrNone& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PrNone& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrNone"; }

 protected:
  explicit PrNone(::google::protobuf::Arena* arena);
  PrNone(::google::protobuf::Arena* arena, const PrNone& from);
  PrNone(::google::protobuf::Arena* arena, PrNone&& from) noexcept
      : PrNone(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:rocvad.PrNone)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrLocalConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrLocalConfig) */ {
 public:
  inline PrLocalConfig() : PrLocalConfig(nullptr) {}
  ~PrLocalConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrLocalConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrLocalConfig(const PrLocalConfig& from) : PrLocalConfig(nullptr, from) {}
  inline PrLocalConfig(PrLocalConfig&& from) noexcept
      : PrLocalConfig(nullptr, std::move(from)) {}
  inline PrLocalConfig& operator=(const PrLocalConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrLocalConfig& operator=(PrLocalConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrLocalConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrLocalConfig* internal_default_instance() {
    return reinterpret_cast<const PrLocalConfig*>(
        &_PrLocalConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(PrLocalConfig& a, PrLocalConfig& b) { a.Swap(&b); }
  inline void Swap(PrLocalConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrLocalConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrLocalConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrLocalConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrLocalConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrLocalConfig& from) { PrLocalConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrLocalConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrLocalConfig"; }

 protected:
  explicit PrLocalConfig(::google::protobuf::Arena* arena);
  PrLocalConfig(::google::protobuf::Arena* arena, const PrLocalConfig& from);
  PrLocalConfig(::google::protobuf::Arena* arena, PrLocalConfig&& from) noexcept
      : PrLocalConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSampleRateFieldNumber = 1,
    kChannelLayoutFieldNumber = 2,
  };
  // optional uint32 sample_rate = 1;
  bool has_sample_rate() const;
  void clear_sample_rate() ;
  ::uint32_t sample_rate() const;
  void set_sample_rate(::uint32_t value);

  private:
  ::uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(::uint32_t value);

  public:
  // optional .rocvad.PrChannelLayout channel_layout = 2;
  bool has_channel_layout() const;
  void clear_channel_layout() ;
  ::rocvad::PrChannelLayout channel_layout() const;
  void set_channel_layout(::rocvad::PrChannelLayout value);

  private:
  ::rocvad::PrChannelLayout _internal_channel_layout() const;
  void _internal_set_channel_layout(::rocvad::PrChannelLayout value);

  public:
  // @@protoc_insertion_point(class_scope:rocvad.PrLocalConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t sample_rate_;
    int channel_layout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrEndpointInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrEndpointInfo) */ {
 public:
  inline PrEndpointInfo() : PrEndpointInfo(nullptr) {}
  ~PrEndpointInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrEndpointInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrEndpointInfo(const PrEndpointInfo& from) : PrEndpointInfo(nullptr, from) {}
  inline PrEndpointInfo(PrEndpointInfo&& from) noexcept
      : PrEndpointInfo(nullptr, std::move(from)) {}
  inline PrEndpointInfo& operator=(const PrEndpointInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrEndpointInfo& operator=(PrEndpointInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrEndpointInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrEndpointInfo* internal_default_instance() {
    return reinterpret_cast<const PrEndpointInfo*>(
        &_PrEndpointInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PrEndpointInfo& a, PrEndpointInfo& b) { a.Swap(&b); }
  inline void Swap(PrEndpointInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrEndpointInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrEndpointInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrEndpointInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrEndpointInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrEndpointInfo& from) { PrEndpointInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrEndpointInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrEndpointInfo"; }

 protected:
  explicit PrEndpointInfo(::google::protobuf::Arena* arena);
  PrEndpointInfo(::google::protobuf::Arena* arena, const PrEndpointInfo& from);
  PrEndpointInfo(::google::protobuf::Arena* arena, PrEndpointInfo&& from) noexcept
      : PrEndpointInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUriFieldNumber = 3,
    kSlotFieldNumber = 1,
    kInterfaceFieldNumber = 2,
  };
  // string uri = 3;
  void clear_uri() ;
  const std::string& uri() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri(Arg_&& arg, Args_... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* value);

  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(
      const std::string& value);
  std::string* _internal_mutable_uri();

  public:
  // optional uint32 slot = 1;
  bool has_slot() const;
  void clear_slot() ;
  ::uint32_t slot() const;
  void set_slot(::uint32_t value);

  private:
  ::uint32_t _internal_slot() const;
  void _internal_set_slot(::uint32_t value);

  public:
  // .rocvad.PrInterface interface = 2;
  void clear_interface() ;
  ::rocvad::PrInterface interface() const;
  void set_interface(::rocvad::PrInterface value);

  private:
  ::rocvad::PrInterface _internal_interface() const;
  void _internal_set_interface(::rocvad::PrInterface value);

  public:
  // @@protoc_insertion_point(class_scope:rocvad.PrEndpointInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uri_;
    ::uint32_t slot_;
    int interface_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrDriverInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrDriverInfo) */ {
 public:
  inline PrDriverInfo() : PrDriverInfo(nullptr) {}
  ~PrDriverInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrDriverInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrDriverInfo(const PrDriverInfo& from) : PrDriverInfo(nullptr, from) {}
  inline PrDriverInfo(PrDriverInfo&& from) noexcept
      : PrDriverInfo(nullptr, std::move(from)) {}
  inline PrDriverInfo& operator=(const PrDriverInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrDriverInfo& operator=(PrDriverInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrDriverInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrDriverInfo* internal_default_instance() {
    return reinterpret_cast<const PrDriverInfo*>(
        &_PrDriverInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(PrDriverInfo& a, PrDriverInfo& b) { a.Swap(&b); }
  inline void Swap(PrDriverInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrDriverInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrDriverInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrDriverInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrDriverInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrDriverInfo& from) { PrDriverInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrDriverInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrDriverInfo"; }

 protected:
  explicit PrDriverInfo(::google::protobuf::Arena* arena);
  PrDriverInfo(::google::protobuf::Arena* arena, const PrDriverInfo& from);
  PrDriverInfo(::google::protobuf::Arena* arena, PrDriverInfo&& from) noexcept
      : PrDriverInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVersionFieldNumber = 1,
    kCommitFieldNumber = 2,
  };
  // string version = 1;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string commit = 2;
  void clear_commit() ;
  const std::string& commit() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_commit(Arg_&& arg, Args_... args);
  std::string* mutable_commit();
  PROTOBUF_NODISCARD std::string* release_commit();
  void set_allocated_commit(std::string* value);

  private:
  const std::string& _internal_commit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commit(
      const std::string& value);
  std::string* _internal_mutable_commit();

  public:
  // @@protoc_insertion_point(class_scope:rocvad.PrDriverInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr commit_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrDeviceSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrDeviceSelector) */ {
 public:
  inline PrDeviceSelector() : PrDeviceSelector(nullptr) {}
  ~PrDeviceSelector() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrDeviceSelector(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrDeviceSelector(const PrDeviceSelector& from) : PrDeviceSelector(nullptr, from) {}
  inline PrDeviceSelector(PrDeviceSelector&& from) noexcept
      : PrDeviceSelector(nullptr, std::move(from)) {}
  inline PrDeviceSelector& operator=(const PrDeviceSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrDeviceSelector& operator=(PrDeviceSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrDeviceSelector& default_instance() {
    return *internal_default_instance();
  }
  enum SelectorCase {
    kIndex = 1,
    kUid = 2,
    SELECTOR_NOT_SET = 0,
  };
  static inline const PrDeviceSelector* internal_default_instance() {
    return reinterpret_cast<const PrDeviceSelector*>(
        &_PrDeviceSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PrDeviceSelector& a, PrDeviceSelector& b) { a.Swap(&b); }
  inline void Swap(PrDeviceSelector* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrDeviceSelector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrDeviceSelector* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrDeviceSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrDeviceSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrDeviceSelector& from) { PrDeviceSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrDeviceSelector* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrDeviceSelector"; }

 protected:
  explicit PrDeviceSelector(::google::protobuf::Arena* arena);
  PrDeviceSelector(::google::protobuf::Arena* arena, const PrDeviceSelector& from);
  PrDeviceSelector(::google::protobuf::Arena* arena, PrDeviceSelector&& from) noexcept
      : PrDeviceSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
    kUidFieldNumber = 2,
  };
  // uint32 index = 1;
  bool has_index() const;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // string uid = 2;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  void clear_Selector();
  SelectorCase Selector_case() const;
  // @@protoc_insertion_point(class_scope:rocvad.PrDeviceSelector)
 private:
  class _Internal;
  void set_has_index();
  void set_has_uid();
  inline bool has_Selector() const;
  inline void clear_has_Selector();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union SelectorUnion {
      constexpr SelectorUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t index_;
      ::google::protobuf::internal::ArenaStringPtr uid_;
    } Selector_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrSenderConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrSenderConfig) */ {
 public:
  inline PrSenderConfig() : PrSenderConfig(nullptr) {}
  ~PrSenderConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrSenderConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrSenderConfig(const PrSenderConfig& from) : PrSenderConfig(nullptr, from) {}
  inline PrSenderConfig(PrSenderConfig&& from) noexcept
      : PrSenderConfig(nullptr, std::move(from)) {}
  inline PrSenderConfig& operator=(const PrSenderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrSenderConfig& operator=(PrSenderConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrSenderConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrSenderConfig* internal_default_instance() {
    return reinterpret_cast<const PrSenderConfig*>(
        &_PrSenderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(PrSenderConfig& a, PrSenderConfig& b) { a.Swap(&b); }
  inline void Swap(PrSenderConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrSenderConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrSenderConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrSenderConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrSenderConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrSenderConfig& from) { PrSenderConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrSenderConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrSenderConfig"; }

 protected:
  explicit PrSenderConfig(::google::protobuf::Arena* arena);
  PrSenderConfig(::google::protobuf::Arena* arena, const PrSenderConfig& from);
  PrSenderConfig(::google::protobuf::Arena* arena, PrSenderConfig&& from) noexcept
      : PrSenderConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPacketLengthFieldNumber = 2,
    kTargetLatencyFieldNumber = 7,
    kMinLatencyFieldNumber = 8,
    kMaxLatencyFieldNumber = 9,
    kPacketEncodingFieldNumber = 1,
    kPacketInterleavingFieldNumber = 3,
    kFecEncodingFieldNumber = 4,
    kFecBlockSourcePacketsFieldNumber = 5,
    kFecBlockRepairPacketsFieldNumber = 6,
    kLatencyTunerBackendFieldNumber = 10,
    kLatencyTunerProfileFieldNumber = 11,
    kResamplerBackendFieldNumber = 12,
    kResamplerProfileFieldNumber = 13,
  };
  // optional .google.protobuf.Duration packet_length = 2;
  bool has_packet_length() const;
  void clear_packet_length() ;
  const ::google::protobuf::Duration& packet_length() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_packet_length();
  ::google::protobuf::Duration* mutable_packet_length();
  void set_allocated_packet_length(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_packet_length(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_packet_length();

  private:
  const ::google::protobuf::Duration& _internal_packet_length() const;
  ::google::protobuf::Duration* _internal_mutable_packet_length();

  public:
  // optional .google.protobuf.Duration target_latency = 7;
  bool has_target_latency() const;
  void clear_target_latency() ;
  const ::google::protobuf::Duration& target_latency() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_target_latency();
  ::google::protobuf::Duration* mutable_target_latency();
  void set_allocated_target_latency(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_target_latency(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_target_latency();

  private:
  const ::google::protobuf::Duration& _internal_target_latency() const;
  ::google::protobuf::Duration* _internal_mutable_target_latency();

  public:
  // optional .google.protobuf.Duration min_latency = 8;
  bool has_min_latency() const;
  void clear_min_latency() ;
  const ::google::protobuf::Duration& min_latency() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_min_latency();
  ::google::protobuf::Duration* mutable_min_latency();
  void set_allocated_min_latency(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_min_latency(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_min_latency();

  private:
  const ::google::protobuf::Duration& _internal_min_latency() const;
  ::google::protobuf::Duration* _internal_mutable_min_latency();

  public:
  // optional .google.protobuf.Duration max_latency = 9;
  bool has_max_latency() const;
  void clear_max_latency() ;
  const ::google::protobuf::Duration& max_latency() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_max_latency();
  ::google::protobuf::Duration* mutable_max_latency();
  void set_allocated_max_latency(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_max_latency(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_max_latency();

  private:
  const ::google::protobuf::Duration& _internal_max_latency() const;
  ::google::protobuf::Duration* _internal_mutable_max_latency();

  public:
  // optional .rocvad.PrPacketEncoding packet_encoding = 1;
  bool has_packet_encoding() const;
  void clear_packet_encoding() ;
  ::rocvad::PrPacketEncoding packet_encoding() const;
  void set_packet_encoding(::rocvad::PrPacketEncoding value);

  private:
  ::rocvad::PrPacketEncoding _internal_packet_encoding() const;
  void _internal_set_packet_encoding(::rocvad::PrPacketEncoding value);

  public:
  // optional bool packet_interleaving = 3;
  bool has_packet_interleaving() const;
  void clear_packet_interleaving() ;
  bool packet_interleaving() const;
  void set_packet_interleaving(bool value);

  private:
  bool _internal_packet_interleaving() const;
  void _internal_set_packet_interleaving(bool value);

  public:
  // optional .rocvad.PrFecEncoding fec_encoding = 4;
  bool has_fec_encoding() const;
  void clear_fec_encoding() ;
  ::rocvad::PrFecEncoding fec_encoding() const;
  void set_fec_encoding(::rocvad::PrFecEncoding value);

  private:
  ::rocvad::PrFecEncoding _internal_fec_encoding() const;
  void _internal_set_fec_encoding(::rocvad::PrFecEncoding value);

  public:
  // optional uint32 fec_block_source_packets = 5;
  bool has_fec_block_source_packets() const;
  void clear_fec_block_source_packets() ;
  ::uint32_t fec_block_source_packets() const;
  void set_fec_block_source_packets(::uint32_t value);

  private:
  ::uint32_t _internal_fec_block_source_packets() const;
  void _internal_set_fec_block_source_packets(::uint32_t value);

  public:
  // optional uint32 fec_block_repair_packets = 6;
  bool has_fec_block_repair_packets() const;
  void clear_fec_block_repair_packets() ;
  ::uint32_t fec_block_repair_packets() const;
  void set_fec_block_repair_packets(::uint32_t value);

  private:
  ::uint32_t _internal_fec_block_repair_packets() const;
  void _internal_set_fec_block_repair_packets(::uint32_t value);

  public:
  // optional .rocvad.PrLatencyTunerBackend latency_tuner_backend = 10;
  bool has_latency_tuner_backend() const;
  void clear_latency_tuner_backend() ;
  ::rocvad::PrLatencyTunerBackend latency_tuner_backend() const;
  void set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value);

  private:
  ::rocvad::PrLatencyTunerBackend _internal_latency_tuner_backend() const;
  void _internal_set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value);

  public:
  // optional .rocvad.PrLatencyTunerProfile latency_tuner_profile = 11;
  bool has_latency_tuner_profile() const;
  void clear_latency_tuner_profile() ;
  ::rocvad::PrLatencyTunerProfile latency_tuner_profile() const;
  void set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value);

  private:
  ::rocvad::PrLatencyTunerProfile _internal_latency_tuner_profile() const;
  void _internal_set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value);

  public:
  // optional .rocvad.PrResamplerBackend resampler_backend = 12;
  bool has_resampler_backend() const;
  void clear_resampler_backend() ;
  ::rocvad::PrResamplerBackend resampler_backend() const;
  void set_resampler_backend(::rocvad::PrResamplerBackend value);

  private:
  ::rocvad::PrResamplerBackend _internal_resampler_backend() const;
  void _internal_set_resampler_backend(::rocvad::PrResamplerBackend value);

  public:
  // optional .rocvad.PrResamplerProfile resampler_profile = 13;
  bool has_resampler_profile() const;
  void clear_resampler_profile() ;
  ::rocvad::PrResamplerProfile resampler_profile() const;
  void set_resampler_profile(::rocvad::PrResamplerProfile value);

  private:
  ::rocvad::PrResamplerProfile _internal_resampler_profile() const;
  void _internal_set_resampler_profile(::rocvad::PrResamplerProfile value);

  public:
  // @@protoc_insertion_point(class_scope:rocvad.PrSenderConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Duration* packet_length_;
    ::google::protobuf::Duration* target_latency_;
    ::google::protobuf::Duration* min_latency_;
    ::google::protobuf::Duration* max_latency_;
    int packet_encoding_;
    bool packet_interleaving_;
    int fec_encoding_;
    ::uint32_t fec_block_source_packets_;
    ::uint32_t fec_block_repair_packets_;
    int latency_tuner_backend_;
    int latency_tuner_profile_;
    int resampler_backend_;
    int resampler_profile_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrReceiverConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrReceiverConfig) */ {
 public:
  inline PrReceiverConfig() : PrReceiverConfig(nullptr) {}
  ~PrReceiverConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrReceiverConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrReceiverConfig(const PrReceiverConfig& from) : PrReceiverConfig(nullptr, from) {}
  inline PrReceiverConfig(PrReceiverConfig&& from) noexcept
      : PrReceiverConfig(nullptr, std::move(from)) {}
  inline PrReceiverConfig& operator=(const PrReceiverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrReceiverConfig& operator=(PrReceiverConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrReceiverConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrReceiverConfig* internal_default_instance() {
    return reinterpret_cast<const PrReceiverConfig*>(
        &_PrReceiverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PrReceiverConfig& a, PrReceiverConfig& b) { a.Swap(&b); }
  inline void Swap(PrReceiverConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrReceiverConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrReceiverConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrReceiverConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrReceiverConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrReceiverConfig& from) { PrReceiverConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrReceiverConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrReceiverConfig"; }

 protected:
  explicit PrReceiverConfig(::google::protobuf::Arena* arena);
  PrReceiverConfig(::google::protobuf::Arena* arena, const PrReceiverConfig& from);
  PrReceiverConfig(::google::protobuf::Arena* arena, PrReceiverConfig&& from) noexcept
      : PrReceiverConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetLatencyFieldNumber = 1,
    kMinLatencyFieldNumber = 2,
    kMaxLatencyFieldNumber = 3,
    kNoPlaybackTimeoutFieldNumber = 8,
    kChoppyPlaybackTimeoutFieldNumber = 9,
    kLatencyTunerBackendFieldNumber = 4,
    kLatencyTunerProfileFieldNumber = 5,
    kResamplerBackendFieldNumber = 6,
    kResamplerProfileFieldNumber = 7,
  };
  // optional .google.protobuf.Duration target_latency = 1;
  bool has_target_latency() const;
  void clear_target_latency() ;
  const ::google::protobuf::Duration& target_latency() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_target_latency();
  ::google::protobuf::Duration* mutable_target_latency();
  void set_allocated_target_latency(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_target_latency(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_target_latency();

  private:
  const ::google::protobuf::Duration& _internal_target_latency() const;
  ::google::protobuf::Duration* _internal_mutable_target_latency();

  public:
  // optional .google.protobuf.Duration min_latency = 2;
  bool has_min_latency() const;
  void clear_min_latency() ;
  const ::google::protobuf::Duration& min_latency() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_min_latency();
  ::google::protobuf::Duration* mutable_min_latency();
  void set_allocated_min_latency(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_min_latency(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_min_latency();

  private:
  const ::google::protobuf::Duration& _internal_min_latency() const;
  ::google::protobuf::Duration* _internal_mutable_min_latency();

  public:
  // optional .google.protobuf.Duration max_latency = 3;
  bool has_max_latency() const;
  void clear_max_latency() ;
  const ::google::protobuf::Duration& max_latency() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_max_latency();
  ::google::protobuf::Duration* mutable_max_latency();
  void set_allocated_max_latency(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_max_latency(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_max_latency();

  private:
  const ::google::protobuf::Duration& _internal_max_latency() const;
  ::google::protobuf::Duration* _internal_mutable_max_latency();

  public:
  // optional .google.protobuf.Duration no_playback_timeout = 8;
  bool has_no_playback_timeout() const;
  void clear_no_playback_timeout() ;
  const ::google::protobuf::Duration& no_playback_timeout() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_no_playback_timeout();
  ::google::protobuf::Duration* mutable_no_playback_timeout();
  void set_allocated_no_playback_timeout(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_no_playback_timeout(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_no_playback_timeout();

  private:
  const ::google::protobuf::Duration& _internal_no_playback_timeout() const;
  ::google::protobuf::Duration* _internal_mutable_no_playback_timeout();

  public:
  // optional .google.protobuf.Duration choppy_playback_timeout = 9;
  bool has_choppy_playback_timeout() const;
  void clear_choppy_playback_timeout() ;
  const ::google::protobuf::Duration& choppy_playback_timeout() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_choppy_playback_timeout();
  ::google::protobuf::Duration* mutable_choppy_playback_timeout();
  void set_allocated_choppy_playback_timeout(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_choppy_playback_timeout(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_choppy_playback_timeout();

  private:
  const ::google::protobuf::Duration& _internal_choppy_playback_timeout() const;
  ::google::protobuf::Duration* _internal_mutable_choppy_playback_timeout();

  public:
  // optional .rocvad.PrLatencyTunerBackend latency_tuner_backend = 4;
  bool has_latency_tuner_backend() const;
  void clear_latency_tuner_backend() ;
  ::rocvad::PrLatencyTunerBackend latency_tuner_backend() const;
  void set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value);

  private:
  ::rocvad::PrLatencyTunerBackend _internal_latency_tuner_backend() const;
  void _internal_set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value);

  public:
  // optional .rocvad.PrLatencyTunerProfile latency_tuner_profile = 5;
  bool has_latency_tuner_profile() const;
  void clear_latency_tuner_profile() ;
  ::rocvad::PrLatencyTunerProfile latency_tuner_profile() const;
  void set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value);

  private:
  ::rocvad::PrLatencyTunerProfile _internal_latency_tuner_profile() const;
  void _internal_set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value);

  public:
  // optional .rocvad.PrResamplerBackend resampler_backend = 6;
  bool has_resampler_backend() const;
  void clear_resampler_backend() ;
  ::rocvad::PrResamplerBackend resampler_backend() const;
  void set_resampler_backend(::rocvad::PrResamplerBackend value);

  private:
  ::rocvad::PrResamplerBackend _internal_resampler_backend() const;
  void _internal_set_resampler_backend(::rocvad::PrResamplerBackend value);

  public:
  // optional .rocvad.PrResamplerProfile resampler_profile = 7;
  bool has_resampler_profile() const;
  void clear_resampler_profile() ;
  ::rocvad::PrResamplerProfile resampler_profile() const;
  void set_resampler_profile(::rocvad::PrResamplerProfile value);

  private:
  ::rocvad::PrResamplerProfile _internal_resampler_profile() const;
  void _internal_set_resampler_profile(::rocvad::PrResamplerProfile value);

  public:
  // @@protoc_insertion_point(class_scope:rocvad.PrReceiverConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Duration* target_latency_;
    ::google::protobuf::Duration* min_latency_;
    ::google::protobuf::Duration* max_latency_;
    ::google::protobuf::Duration* no_playback_timeout_;
    ::google::protobuf::Duration* choppy_playback_timeout_;
    int latency_tuner_backend_;
    int latency_tuner_profile_;
    int resampler_backend_;
    int resampler_profile_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrLogEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrLogEntry) */ {
 public:
  inline PrLogEntry() : PrLogEntry(nullptr) {}
  ~PrLogEntry() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrLogEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrLogEntry(const PrLogEntry& from) : PrLogEntry(nullptr, from) {}
  inline PrLogEntry(PrLogEntry&& from) noexcept
      : PrLogEntry(nullptr, std::move(from)) {}
  inline PrLogEntry& operator=(const PrLogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrLogEntry& operator=(PrLogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrLogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrLogEntry* internal_default_instance() {
    return reinterpret_cast<const PrLogEntry*>(
        &_PrLogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(PrLogEntry& a, PrLogEntry& b) { a.Swap(&b); }
  inline void Swap(PrLogEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrLogEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrLogEntry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrLogEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrLogEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrLogEntry& from) { PrLogEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrLogEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrLogEntry"; }

 protected:
  explicit PrLogEntry(::google::protobuf::Arena* arena);
  PrLogEntry(::google::protobuf::Arena* arena, const PrLogEntry& from);
  PrLogEntry(::google::protobuf::Arena* arena, PrLogEntry&& from) noexcept
      : PrLogEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Level = PrLogEntry_Level;
  static constexpr Level CRIT = PrLogEntry_Level_CRIT;
  static constexpr Level ERROR = PrLogEntry_Level_ERROR;
  static constexpr Level WARN = PrLogEntry_Level_WARN;
  static constexpr Level INFO = PrLogEntry_Level_INFO;
  static constexpr Level DEBUG = PrLogEntry_Level_DEBUG;
  static constexpr Level TRACE = PrLogEntry_Level_TRACE;
  static inline bool Level_IsValid(int value) {
    return PrLogEntry_Level_IsValid(value);
  }
  static constexpr Level Level_MIN = PrLogEntry_Level_Level_MIN;
  static constexpr Level Level_MAX = PrLogEntry_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE = PrLogEntry_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Level_descriptor() {
    return PrLogEntry_Level_descriptor();
  }
  template <typename T>
  static inline const std::string& Level_Name(T value) {
    return PrLogEntry_Level_Name(value);
  }
  static inline bool Level_Parse(absl::string_view name, Level* value) {
    return PrLogEntry_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 3,
    kTimeFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // string text = 3;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .rocvad.PrLogEntry.Level level = 2;
  void clear_level() ;
  ::rocvad::PrLogEntry_Level level() const;
  void set_level(::rocvad::PrLogEntry_Level value);

  private:
  ::rocvad::PrLogEntry_Level _internal_level() const;
  void _internal_set_level(::rocvad::PrLogEntry_Level value);

  public:
  // @@protoc_insertion_point(class_scope:rocvad.PrLogEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::Timestamp* time_;
    int level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrEndpointRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrEndpointRequest) */ {
 public:
  inline PrEndpointRequest() : PrEndpointRequest(nullptr) {}
  ~PrEndpointRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrEndpointRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrEndpointRequest(const PrEndpointRequest& from) : PrEndpointRequest(nullptr, from) {}
  inline PrEndpointRequest(PrEndpointRequest&& from) noexcept
      : PrEndpointRequest(nullptr, std::move(from)) {}
  inline PrEndpointRequest& operator=(const PrEndpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrEndpointRequest& operator=(PrEndpointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrEndpointRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrEndpointRequest* internal_default_instance() {
    return reinterpret_cast<const PrEndpointRequest*>(
        &_PrEndpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PrEndpointRequest& a, PrEndpointRequest& b) { a.Swap(&b); }
  inline void Swap(PrEndpointRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrEndpointRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrEndpointRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrEndpointRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrEndpointRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrEndpointRequest& from) { PrEndpointRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrEndpointRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrEndpointRequest"; }

 protected:
  explicit PrEndpointRequest(::google::protobuf::Arena* arena);
  PrEndpointRequest(::google::protobuf::Arena* arena, const PrEndpointRequest& from);
  PrEndpointRequest(::google::protobuf::Arena* arena, PrEndpointRequest&& from) noexcept
      : PrEndpointRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceFieldNumber = 1,
    kEndpointFieldNumber = 2,
  };
  // .rocvad.PrDeviceSelector device = 1;
  bool has_device() const;
  void clear_device() ;
  const ::rocvad::PrDeviceSelector& device() const;
  PROTOBUF_NODISCARD ::rocvad::PrDeviceSelector* release_device();
  ::rocvad::PrDeviceSelector* mutable_device();
  void set_allocated_device(::rocvad::PrDeviceSelector* value);
  void unsafe_arena_set_allocated_device(::rocvad::PrDeviceSelector* value);
  ::rocvad::PrDeviceSelector* unsafe_arena_release_device();

  private:
  const ::rocvad::PrDeviceSelector& _internal_device() const;
  ::rocvad::PrDeviceSelector* _internal_mutable_device();

  public:
  // .rocvad.PrEndpointInfo endpoint = 2;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::rocvad::PrEndpointInfo& endpoint() const;
  PROTOBUF_NODISCARD ::rocvad::PrEndpointInfo* release_endpoint();
  ::rocvad::PrEndpointInfo* mutable_endpoint();
  void set_allocated_endpoint(::rocvad::PrEndpointInfo* value);
  void unsafe_arena_set_allocated_endpoint(::rocvad::PrEndpointInfo* value);
  ::rocvad::PrEndpointInfo* unsafe_arena_release_endpoint();

  private:
  const ::rocvad::PrEndpointInfo& _internal_endpoint() const;
  ::rocvad::PrEndpointInfo* _internal_mutable_endpoint();

  public:
  // @@protoc_insertion_point(class_scope:rocvad.PrEndpointRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::rocvad::PrDeviceSelector* device_;
    ::rocvad::PrEndpointInfo* endpoint_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrDeviceInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrDeviceInfo) */ {
 public:
  inline PrDeviceInfo() : PrDeviceInfo(nullptr) {}
  ~PrDeviceInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrDeviceInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrDeviceInfo(const PrDeviceInfo& from) : PrDeviceInfo(nullptr, from) {}
  inline PrDeviceInfo(PrDeviceInfo&& from) noexcept
      : PrDeviceInfo(nullptr, std::move(from)) {}
  inline PrDeviceInfo& operator=(const PrDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrDeviceInfo& operator=(PrDeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrDeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  enum NetworkConfigCase {
    kSenderConfig = 6,
    kReceiverConfig = 7,
    NETWORKCONFIG_NOT_SET = 0,
  };
  static inline const PrDeviceInfo* internal_default_instance() {
    return reinterpret_cast<const PrDeviceInfo*>(
        &_PrDeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(PrDeviceInfo& a, PrDeviceInfo& b) { a.Swap(&b); }
  inline void Swap(PrDeviceInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrDeviceInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrDeviceInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrDeviceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrDeviceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrDeviceInfo& from) { PrDeviceInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrDeviceInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrDeviceInfo"; }

 protected:
  explicit PrDeviceInfo(::google::protobuf::Arena* arena);
  PrDeviceInfo(::google::protobuf::Arena* arena, const PrDeviceInfo& from);
  PrDeviceInfo(::google::protobuf::Arena* arena, PrDeviceInfo&& from) noexcept
      : PrDeviceInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLocalEndpointsFieldNumber = 8,
    kRemoteEndpointsFieldNumber = 9,
    kUidFieldNumber = 3,
    kNameFieldNumber = 4,
    kLocalConfigFieldNumber = 5,
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 2,
    kSenderConfigFieldNumber = 6,
    kReceiverConfigFieldNumber = 7,
  };
  // repeated .rocvad.PrEndpointInfo local_endpoints = 8;
  int local_endpoints_size() const;
  private:
  int _internal_local_endpoints_size() const;

  public:
  void clear_local_endpoints() ;
  ::rocvad::PrEndpointInfo* mutable_local_endpoints(int index);
  ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>* mutable_local_endpoints();

  private:
  const ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>& _internal_local_endpoints() const;
  ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>* _internal_mutable_local_endpoints();
  public:
  const ::rocvad::PrEndpointInfo& local_endpoints(int index) const;
  ::rocvad::PrEndpointInfo* add_local_endpoints();
  const ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>& local_endpoints() const;
  // repeated .rocvad.PrEndpointInfo remote_endpoints = 9;
  int remote_endpoints_size() const;
  private:
  int _internal_remote_endpoints_size() const;

  public:
  void clear_remote_endpoints() ;
  ::rocvad::PrEndpointInfo* mutable_remote_endpoints(int index);
  ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>* mutable_remote_endpoints();

  private:
  const ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>& _internal_remote_endpoints() const;
  ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>* _internal_mutable_remote_endpoints();
  public:
  const ::rocvad::PrEndpointInfo& remote_endpoints(int index) const;
  ::rocvad::PrEndpointInfo* add_remote_endpoints();
  const ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>& remote_endpoints() const;
  // optional string uid = 3;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // optional string name = 4;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .rocvad.PrLocalConfig local_config = 5;
  bool has_local_config() const;
  void clear_local_config() ;
  const ::rocvad::PrLocalConfig& local_config() const;
  PROTOBUF_NODISCARD ::rocvad::PrLocalConfig* release_local_config();
  ::rocvad::PrLocalConfig* mutable_local_config();
  void set_allocated_local_config(::rocvad::PrLocalConfig* value);
  void unsafe_arena_set_allocated_local_config(::rocvad::PrLocalConfig* value);
  ::rocvad::PrLocalConfig* unsafe_arena_release_local_config();

  private:
  const ::rocvad::PrLocalConfig& _internal_local_config() const;
  ::rocvad::PrLocalConfig* _internal_mutable_local_config();

  public:
  // .rocvad.PrDeviceType type = 1;
  void clear_type() ;
  ::rocvad::PrDeviceType type() const;
  void set_type(::rocvad::PrDeviceType value);

  private:
  ::rocvad::PrDeviceType _internal_type() const;
  void _internal_set_type(::rocvad::PrDeviceType value);

  public:
  // optional uint32 index = 2;
  bool has_index() const;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // .rocvad.PrSenderConfig sender_config = 6;
  bool has_sender_config() const;
  private:
  bool _internal_has_sender_config() const;

  public:
  void clear_sender_config() ;
  const ::rocvad::PrSenderConfig& sender_config() const;
  PROTOBUF_NODISCARD ::rocvad::PrSenderConfig* release_sender_config();
  ::rocvad::PrSenderConfig* mutable_sender_config();
  void set_allocated_sender_config(::rocvad::PrSenderConfig* value);
  void unsafe_arena_set_allocated_sender_config(::rocvad::PrSenderConfig* value);
  ::rocvad::PrSenderConfig* unsafe_arena_release_sender_config();

  private:
  const ::rocvad::PrSenderConfig& _internal_sender_config() const;
  ::rocvad::PrSenderConfig* _internal_mutable_sender_config();

  public:
  // .rocvad.PrReceiverConfig receiver_config = 7;
  bool has_receiver_config() const;
  private:
  bool _internal_has_receiver_config() const;

  public:
  void clear_receiver_config() ;
  const ::rocvad::PrReceiverConfig& receiver_config() const;
  PROTOBUF_NODISCARD ::rocvad::PrReceiverConfig* release_receiver_config();
  ::rocvad::PrReceiverConfig* mutable_receiver_config();
  void set_allocated_receiver_config(::rocvad::PrReceiverConfig* value);
  void unsafe_arena_set_allocated_receiver_config(::rocvad::PrReceiverConfig* value);
  ::rocvad::PrReceiverConfig* unsafe_arena_release_receiver_config();

  private:
  const ::rocvad::PrReceiverConfig& _internal_receiver_config() const;
  ::rocvad::PrReceiverConfig* _internal_mutable_receiver_config();

  public:
  void clear_NetworkConfig();
  NetworkConfigCase NetworkConfig_case() const;
  // @@protoc_insertion_point(class_scope:rocvad.PrDeviceInfo)
 private:
  class _Internal;
  void set_has_sender_config();
  void set_has_receiver_config();
  inline bool has_NetworkConfig() const;
  inline void clear_has_NetworkConfig();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 5,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::rocvad::PrEndpointInfo > local_endpoints_;
    ::google::protobuf::RepeatedPtrField< ::rocvad::PrEndpointInfo > remote_endpoints_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::rocvad::PrLocalConfig* local_config_;
    int type_;
    ::uint32_t index_;
    union NetworkConfigUnion {
      constexpr NetworkConfigUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::rocvad::PrSenderConfig* sender_config_;
      ::rocvad::PrReceiverConfig* receiver_config_;
    } NetworkConfig_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrDeviceList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rocvad.PrDeviceList) */ {
 public:
  inline PrDeviceList() : PrDeviceList(nullptr) {}
  ~PrDeviceList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrDeviceList(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrDeviceList(const PrDeviceList& from) : PrDeviceList(nullptr, from) {}
  inline PrDeviceList(PrDeviceList&& from) noexcept
      : PrDeviceList(nullptr, std::move(from)) {}
  inline PrDeviceList& operator=(const PrDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrDeviceList& operator=(PrDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrDeviceList* internal_default_instance() {
    return reinterpret_cast<const PrDeviceList*>(
        &_PrDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(PrDeviceList& a, PrDeviceList& b) { a.Swap(&b); }
  inline void Swap(PrDeviceList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrDeviceList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrDeviceList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrDeviceList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrDeviceList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrDeviceList& from) { PrDeviceList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrDeviceList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rocvad.PrDeviceList"; }

 protected:
  explicit PrDeviceList(::google::protobuf::Arena* arena);
  PrDeviceList(::google::protobuf::Arena* arena, const PrDeviceList& from);
  PrDeviceList(::google::protobuf::Arena* arena, PrDeviceList&& from) noexcept
      : PrDeviceList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .rocvad.PrDeviceInfo devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;

  public:
  void clear_devices() ;
  ::rocvad::PrDeviceInfo* mutable_devices(int index);
  ::google::protobuf::RepeatedPtrField<::rocvad::PrDeviceInfo>* mutable_devices();

  private:
  const ::google::protobuf::RepeatedPtrField<::rocvad::PrDeviceInfo>& _internal_devices() const;
  ::google::protobuf::RepeatedPtrField<::rocvad::PrDeviceInfo>* _internal_mutable_devices();
  public:
  const ::rocvad::PrDeviceInfo& devices(int index) const;
  ::rocvad::PrDeviceInfo* add_devices();
  const ::google::protobuf::RepeatedPtrField<::rocvad::PrDeviceInfo>& devices() const;
  // @@protoc_insertion_point(class_scope:rocvad.PrDeviceList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::rocvad::PrDeviceInfo > devices_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PrNone

// -------------------------------------------------------------------

// PrDriverInfo

// string version = 1;
inline void PrDriverInfo::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& PrDriverInfo::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDriverInfo.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrDriverInfo::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rocvad.PrDriverInfo.version)
}
inline std::string* PrDriverInfo::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDriverInfo.version)
  return _s;
}
inline const std::string& PrDriverInfo::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void PrDriverInfo::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.Set(value, GetArena());
}
inline std::string* PrDriverInfo::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* PrDriverInfo::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrDriverInfo.version)
  return _impl_.version_.Release();
}
inline void PrDriverInfo::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDriverInfo.version)
}

// string commit = 2;
inline void PrDriverInfo::clear_commit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_.ClearToEmpty();
}
inline const std::string& PrDriverInfo::commit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDriverInfo.commit)
  return _internal_commit();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrDriverInfo::set_commit(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rocvad.PrDriverInfo.commit)
}
inline std::string* PrDriverInfo::mutable_commit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDriverInfo.commit)
  return _s;
}
inline const std::string& PrDriverInfo::_internal_commit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commit_.Get();
}
inline void PrDriverInfo::_internal_set_commit(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_.Set(value, GetArena());
}
inline std::string* PrDriverInfo::_internal_mutable_commit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.commit_.Mutable( GetArena());
}
inline std::string* PrDriverInfo::release_commit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrDriverInfo.commit)
  return _impl_.commit_.Release();
}
inline void PrDriverInfo::set_allocated_commit(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.commit_.IsDefault()) {
          _impl_.commit_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDriverInfo.commit)
}

// -------------------------------------------------------------------

// PrLogEntry

// .google.protobuf.Timestamp time = 1;
inline bool PrLogEntry::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& PrLogEntry::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& PrLogEntry::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrLogEntry.time)
  return _internal_time();
}
inline void PrLogEntry::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrLogEntry.time)
}
inline ::google::protobuf::Timestamp* PrLogEntry::release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* PrLogEntry::unsafe_arena_release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrLogEntry.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PrLogEntry::_internal_mutable_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* PrLogEntry::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:rocvad.PrLogEntry.time)
  return _msg;
}
inline void PrLogEntry::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrLogEntry.time)
}

// .rocvad.PrLogEntry.Level level = 2;
inline void PrLogEntry::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::rocvad::PrLogEntry_Level PrLogEntry::level() const {
  // @@protoc_insertion_point(field_get:rocvad.PrLogEntry.level)
  return _internal_level();
}
inline void PrLogEntry::set_level(::rocvad::PrLogEntry_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:rocvad.PrLogEntry.level)
}
inline ::rocvad::PrLogEntry_Level PrLogEntry::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrLogEntry_Level>(_impl_.level_);
}
inline void PrLogEntry::_internal_set_level(::rocvad::PrLogEntry_Level value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = value;
}

// string text = 3;
inline void PrLogEntry::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& PrLogEntry::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrLogEntry.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrLogEntry::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rocvad.PrLogEntry.text)
}
inline std::string* PrLogEntry::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:rocvad.PrLogEntry.text)
  return _s;
}
inline const std::string& PrLogEntry::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void PrLogEntry::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Set(value, GetArena());
}
inline std::string* PrLogEntry::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* PrLogEntry::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrLogEntry.text)
  return _impl_.text_.Release();
}
inline void PrLogEntry::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrLogEntry.text)
}

// -------------------------------------------------------------------

// PrDeviceSelector

// uint32 index = 1;
inline bool PrDeviceSelector::has_index() const {
  return Selector_case() == kIndex;
}
inline void PrDeviceSelector::set_has_index() {
  _impl_._oneof_case_[0] = kIndex;
}
inline void PrDeviceSelector::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() == kIndex) {
    _impl_.Selector_.index_ = 0u;
    clear_has_Selector();
  }
}
inline ::uint32_t PrDeviceSelector::index() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceSelector.index)
  return _internal_index();
}
inline void PrDeviceSelector::set_index(::uint32_t value) {
  if (Selector_case() != kIndex) {
    clear_Selector();
    set_has_index();
  }
  _impl_.Selector_.index_ = value;
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceSelector.index)
}
inline ::uint32_t PrDeviceSelector::_internal_index() const {
  if (Selector_case() == kIndex) {
    return _impl_.Selector_.index_;
  }
  return 0u;
}

// string uid = 2;
inline bool PrDeviceSelector::has_uid() const {
  return Selector_case() == kUid;
}
inline void PrDeviceSelector::set_has_uid() {
  _impl_._oneof_case_[0] = kUid;
}
inline void PrDeviceSelector::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() == kUid) {
    _impl_.Selector_.uid_.Destroy();
    clear_has_Selector();
  }
}
inline const std::string& PrDeviceSelector::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceSelector.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrDeviceSelector::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() != kUid) {
    clear_Selector();

    set_has_uid();
    _impl_.Selector_.uid_.InitDefault();
  }
  _impl_.Selector_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceSelector.uid)
}
inline std::string* PrDeviceSelector::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceSelector.uid)
  return _s;
}
inline const std::string& PrDeviceSelector::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (Selector_case() != kUid) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.Selector_.uid_.Get();
}
inline void PrDeviceSelector::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() != kUid) {
    clear_Selector();

    set_has_uid();
    _impl_.Selector_.uid_.InitDefault();
  }
  _impl_.Selector_.uid_.Set(value, GetArena());
}
inline std::string* PrDeviceSelector::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() != kUid) {
    clear_Selector();

    set_has_uid();
    _impl_.Selector_.uid_.InitDefault();
  }
  return _impl_.Selector_.uid_.Mutable( GetArena());
}
inline std::string* PrDeviceSelector::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceSelector.uid)
  if (Selector_case() != kUid) {
    return nullptr;
  }
  clear_has_Selector();
  return _impl_.Selector_.uid_.Release();
}
inline void PrDeviceSelector::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_Selector()) {
    clear_Selector();
  }
  if (value != nullptr) {
    set_has_uid();
    _impl_.Selector_.uid_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDeviceSelector.uid)
}

inline bool PrDeviceSelector::has_Selector() const {
  return Selector_case() != SELECTOR_NOT_SET;
}
inline void PrDeviceSelector::clear_has_Selector() {
  _impl_._oneof_case_[0] = SELECTOR_NOT_SET;
}
inline PrDeviceSelector::SelectorCase PrDeviceSelector::Selector_case() const {
  return PrDeviceSelector::SelectorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PrDeviceInfo

// .rocvad.PrDeviceType type = 1;
inline void PrDeviceInfo::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::rocvad::PrDeviceType PrDeviceInfo::type() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.type)
  return _internal_type();
}
inline void PrDeviceInfo::set_type(::rocvad::PrDeviceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceInfo.type)
}
inline ::rocvad::PrDeviceType PrDeviceInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrDeviceType>(_impl_.type_);
}
inline void PrDeviceInfo::_internal_set_type(::rocvad::PrDeviceType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional uint32 index = 2;
inline bool PrDeviceInfo::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PrDeviceInfo::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t PrDeviceInfo::index() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.index)
  return _internal_index();
}
inline void PrDeviceInfo::set_index(::uint32_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceInfo.index)
}
inline ::uint32_t PrDeviceInfo::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void PrDeviceInfo::_internal_set_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = value;
}

// optional string uid = 3;
inline bool PrDeviceInfo::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PrDeviceInfo::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrDeviceInfo::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrDeviceInfo::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceInfo.uid)
}
inline std::string* PrDeviceInfo::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.uid)
  return _s;
}
inline const std::string& PrDeviceInfo::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void PrDeviceInfo::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* PrDeviceInfo::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* PrDeviceInfo::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PrDeviceInfo::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDeviceInfo.uid)
}

// optional string name = 4;
inline bool PrDeviceInfo::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PrDeviceInfo::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PrDeviceInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrDeviceInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceInfo.name)
}
inline std::string* PrDeviceInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.name)
  return _s;
}
inline const std::string& PrDeviceInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void PrDeviceInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PrDeviceInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PrDeviceInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PrDeviceInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDeviceInfo.name)
}

// .rocvad.PrLocalConfig local_config = 5;
inline bool PrDeviceInfo::has_local_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.local_config_ != nullptr);
  return value;
}
inline void PrDeviceInfo::clear_local_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.local_config_ != nullptr) _impl_.local_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::rocvad::PrLocalConfig& PrDeviceInfo::_internal_local_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rocvad::PrLocalConfig* p = _impl_.local_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocvad::PrLocalConfig&>(::rocvad::_PrLocalConfig_default_instance_);
}
inline const ::rocvad::PrLocalConfig& PrDeviceInfo::local_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.local_config)
  return _internal_local_config();
}
inline void PrDeviceInfo::unsafe_arena_set_allocated_local_config(::rocvad::PrLocalConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.local_config_);
  }
  _impl_.local_config_ = reinterpret_cast<::rocvad::PrLocalConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrDeviceInfo.local_config)
}
inline ::rocvad::PrLocalConfig* PrDeviceInfo::release_local_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::rocvad::PrLocalConfig* released = _impl_.local_config_;
  _impl_.local_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rocvad::PrLocalConfig* PrDeviceInfo::unsafe_arena_release_local_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.local_config)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::rocvad::PrLocalConfig* temp = _impl_.local_config_;
  _impl_.local_config_ = nullptr;
  return temp;
}
inline ::rocvad::PrLocalConfig* PrDeviceInfo::_internal_mutable_local_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.local_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::rocvad::PrLocalConfig>(GetArena());
    _impl_.local_config_ = reinterpret_cast<::rocvad::PrLocalConfig*>(p);
  }
  return _impl_.local_config_;
}
inline ::rocvad::PrLocalConfig* PrDeviceInfo::mutable_local_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::rocvad::PrLocalConfig* _msg = _internal_mutable_local_config();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.local_config)
  return _msg;
}
inline void PrDeviceInfo::set_allocated_local_config(::rocvad::PrLocalConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.local_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.local_config_ = reinterpret_cast<::rocvad::PrLocalConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDeviceInfo.local_config)
}

// .rocvad.PrSenderConfig sender_config = 6;
inline bool PrDeviceInfo::has_sender_config() const {
  return NetworkConfig_case() == kSenderConfig;
}
inline bool PrDeviceInfo::_internal_has_sender_config() const {
  return NetworkConfig_case() == kSenderConfig;
}
inline void PrDeviceInfo::set_has_sender_config() {
  _impl_._oneof_case_[0] = kSenderConfig;
}
inline void PrDeviceInfo::clear_sender_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (NetworkConfig_case() == kSenderConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.NetworkConfig_.sender_config_;
    }
    clear_has_NetworkConfig();
  }
}
inline ::rocvad::PrSenderConfig* PrDeviceInfo::release_sender_config() {
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.sender_config)
  if (NetworkConfig_case() == kSenderConfig) {
    clear_has_NetworkConfig();
    auto* temp = _impl_.NetworkConfig_.sender_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.NetworkConfig_.sender_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocvad::PrSenderConfig& PrDeviceInfo::_internal_sender_config() const {
  return NetworkConfig_case() == kSenderConfig ? *_impl_.NetworkConfig_.sender_config_ : reinterpret_cast<::rocvad::PrSenderConfig&>(::rocvad::_PrSenderConfig_default_instance_);
}
inline const ::rocvad::PrSenderConfig& PrDeviceInfo::sender_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.sender_config)
  return _internal_sender_config();
}
inline ::rocvad::PrSenderConfig* PrDeviceInfo::unsafe_arena_release_sender_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocvad.PrDeviceInfo.sender_config)
  if (NetworkConfig_case() == kSenderConfig) {
    clear_has_NetworkConfig();
    auto* temp = _impl_.NetworkConfig_.sender_config_;
    _impl_.NetworkConfig_.sender_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PrDeviceInfo::unsafe_arena_set_allocated_sender_config(::rocvad::PrSenderConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_NetworkConfig();
  if (value) {
    set_has_sender_config();
    _impl_.NetworkConfig_.sender_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrDeviceInfo.sender_config)
}
inline ::rocvad::PrSenderConfig* PrDeviceInfo::_internal_mutable_sender_config() {
  if (NetworkConfig_case() != kSenderConfig) {
    clear_NetworkConfig();
    set_has_sender_config();
    _impl_.NetworkConfig_.sender_config_ =
        ::google::protobuf::Message::DefaultConstruct<::rocvad::PrSenderConfig>(GetArena());
  }
  return _impl_.NetworkConfig_.sender_config_;
}
inline ::rocvad::PrSenderConfig* PrDeviceInfo::mutable_sender_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rocvad::PrSenderConfig* _msg = _internal_mutable_sender_config();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.sender_config)
  return _msg;
}

// .rocvad.PrReceiverConfig receiver_config = 7;
inline bool PrDeviceInfo::has_receiver_config() const {
  return NetworkConfig_case() == kReceiverConfig;
}
inline bool PrDeviceInfo::_internal_has_receiver_config() const {
  return NetworkConfig_case() == kReceiverConfig;
}
inline void PrDeviceInfo::set_has_receiver_config() {
  _impl_._oneof_case_[0] = kReceiverConfig;
}
inline void PrDeviceInfo::clear_receiver_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (NetworkConfig_case() == kReceiverConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.NetworkConfig_.receiver_config_;
    }
    clear_has_NetworkConfig();
  }
}
inline ::rocvad::PrReceiverConfig* PrDeviceInfo::release_receiver_config() {
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.receiver_config)
  if (NetworkConfig_case() == kReceiverConfig) {
    clear_has_NetworkConfig();
    auto* temp = _impl_.NetworkConfig_.receiver_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.NetworkConfig_.receiver_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocvad::PrReceiverConfig& PrDeviceInfo::_internal_receiver_config() const {
  return NetworkConfig_case() == kReceiverConfig ? *_impl_.NetworkConfig_.receiver_config_ : reinterpret_cast<::rocvad::PrReceiverConfig&>(::rocvad::_PrReceiverConfig_default_instance_);
}
inline const ::rocvad::PrReceiverConfig& PrDeviceInfo::receiver_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.receiver_config)
  return _internal_receiver_config();
}
inline ::rocvad::PrReceiverConfig* PrDeviceInfo::unsafe_arena_release_receiver_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocvad.PrDeviceInfo.receiver_config)
  if (NetworkConfig_case() == kReceiverConfig) {
    clear_has_NetworkConfig();
    auto* temp = _impl_.NetworkConfig_.receiver_config_;
    _impl_.NetworkConfig_.receiver_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PrDeviceInfo::unsafe_arena_set_allocated_receiver_config(::rocvad::PrReceiverConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_NetworkConfig();
  if (value) {
    set_has_receiver_config();
    _impl_.NetworkConfig_.receiver_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrDeviceInfo.receiver_config)
}
inline ::rocvad::PrReceiverConfig* PrDeviceInfo::_internal_mutable_receiver_config() {
  if (NetworkConfig_case() != kReceiverConfig) {
    clear_NetworkConfig();
    set_has_receiver_config();
    _impl_.NetworkConfig_.receiver_config_ =
        ::google::protobuf::Message::DefaultConstruct<::rocvad::PrReceiverConfig>(GetArena());
  }
  return _impl_.NetworkConfig_.receiver_config_;
}
inline ::rocvad::PrReceiverConfig* PrDeviceInfo::mutable_receiver_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rocvad::PrReceiverConfig* _msg = _internal_mutable_receiver_config();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.receiver_config)
  return _msg;
}

// repeated .rocvad.PrEndpointInfo local_endpoints = 8;
inline int PrDeviceInfo::_internal_local_endpoints_size() const {
  return _internal_local_endpoints().size();
}
inline int PrDeviceInfo::local_endpoints_size() const {
  return _internal_local_endpoints_size();
}
inline void PrDeviceInfo::clear_local_endpoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_endpoints_.Clear();
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::mutable_local_endpoints(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.local_endpoints)
  return _internal_mutable_local_endpoints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>* PrDeviceInfo::mutable_local_endpoints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rocvad.PrDeviceInfo.local_endpoints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_local_endpoints();
}
inline const ::rocvad::PrEndpointInfo& PrDeviceInfo::local_endpoints(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.local_endpoints)
  return _internal_local_endpoints().Get(index);
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::add_local_endpoints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rocvad::PrEndpointInfo* _add = _internal_mutable_local_endpoints()->Add();
  // @@protoc_insertion_point(field_add:rocvad.PrDeviceInfo.local_endpoints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>& PrDeviceInfo::local_endpoints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rocvad.PrDeviceInfo.local_endpoints)
  return _internal_local_endpoints();
}
inline const ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>&
PrDeviceInfo::_internal_local_endpoints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.local_endpoints_;
}
inline ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>*
PrDeviceInfo::_internal_mutable_local_endpoints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.local_endpoints_;
}

// repeated .rocvad.PrEndpointInfo remote_endpoints = 9;
inline int PrDeviceInfo::_internal_remote_endpoints_size() const {
  return _internal_remote_endpoints().size();
}
inline int PrDeviceInfo::remote_endpoints_size() const {
  return _internal_remote_endpoints_size();
}
inline void PrDeviceInfo::clear_remote_endpoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remote_endpoints_.Clear();
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::mutable_remote_endpoints(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.remote_endpoints)
  return _internal_mutable_remote_endpoints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>* PrDeviceInfo::mutable_remote_endpoints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rocvad.PrDeviceInfo.remote_endpoints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_remote_endpoints();
}
inline const ::rocvad::PrEndpointInfo& PrDeviceInfo::remote_endpoints(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.remote_endpoints)
  return _internal_remote_endpoints().Get(index);
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::add_remote_endpoints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rocvad::PrEndpointInfo* _add = _internal_mutable_remote_endpoints()->Add();
  // @@protoc_insertion_point(field_add:rocvad.PrDeviceInfo.remote_endpoints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>& PrDeviceInfo::remote_endpoints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rocvad.PrDeviceInfo.remote_endpoints)
  return _internal_remote_endpoints();
}
inline const ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>&
PrDeviceInfo::_internal_remote_endpoints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remote_endpoints_;
}
inline ::google::protobuf::RepeatedPtrField<::rocvad::PrEndpointInfo>*
PrDeviceInfo::_internal_mutable_remote_endpoints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.remote_endpoints_;
}

inline bool PrDeviceInfo::has_NetworkConfig() const {
  return NetworkConfig_case() != NETWORKCONFIG_NOT_SET;
}
inline void PrDeviceInfo::clear_has_NetworkConfig() {
  _impl_._oneof_case_[0] = NETWORKCONFIG_NOT_SET;
}
inline PrDeviceInfo::NetworkConfigCase PrDeviceInfo::NetworkConfig_case() const {
  return PrDeviceInfo::NetworkConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PrDeviceList

// repeated .rocvad.PrDeviceInfo devices = 1;
inline int PrDeviceList::_internal_devices_size() const {
  return _internal_devices().size();
}
inline int PrDeviceList::devices_size() const {
  return _internal_devices_size();
}
inline void PrDeviceList::clear_devices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.devices_.Clear();
}
inline ::rocvad::PrDeviceInfo* PrDeviceList::mutable_devices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceList.devices)
  return _internal_mutable_devices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rocvad::PrDeviceInfo>* PrDeviceList::mutable_devices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rocvad.PrDeviceList.devices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_devices();
}
inline const ::rocvad::PrDeviceInfo& PrDeviceList::devices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceList.devices)
  return _internal_devices().Get(index);
}
inline ::rocvad::PrDeviceInfo* PrDeviceList::add_devices() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rocvad::PrDeviceInfo* _add = _internal_mutable_devices()->Add();
  // @@protoc_insertion_point(field_add:rocvad.PrDeviceList.devices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rocvad::PrDeviceInfo>& PrDeviceList::devices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rocvad.PrDeviceList.devices)
  return _internal_devices();
}
inline const ::google::protobuf::RepeatedPtrField<::rocvad::PrDeviceInfo>&
PrDeviceList::_internal_devices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.devices_;
}
inline ::google::protobuf::RepeatedPtrField<::rocvad::PrDeviceInfo>*
PrDeviceList::_internal_mutable_devices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.devices_;
}

// -------------------------------------------------------------------

// PrEndpointRequest

// .rocvad.PrDeviceSelector device = 1;
inline bool PrEndpointRequest::has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_ != nullptr);
  return value;
}
inline void PrEndpointRequest::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.device_ != nullptr) _impl_.device_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rocvad::PrDeviceSelector& PrEndpointRequest::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rocvad::PrDeviceSelector* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocvad::PrDeviceSelector&>(::rocvad::_PrDeviceSelector_default_instance_);
}
inline const ::rocvad::PrDeviceSelector& PrEndpointRequest::device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointRequest.device)
  return _internal_device();
}
inline void PrEndpointRequest::unsafe_arena_set_allocated_device(::rocvad::PrDeviceSelector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = reinterpret_cast<::rocvad::PrDeviceSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrEndpointRequest.device)
}
inline ::rocvad::PrDeviceSelector* PrEndpointRequest::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rocvad::PrDeviceSelector* released = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rocvad::PrDeviceSelector* PrEndpointRequest::unsafe_arena_release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrEndpointRequest.device)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rocvad::PrDeviceSelector* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::rocvad::PrDeviceSelector* PrEndpointRequest::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.device_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::rocvad::PrDeviceSelector>(GetArena());
    _impl_.device_ = reinterpret_cast<::rocvad::PrDeviceSelector*>(p);
  }
  return _impl_.device_;
}
inline ::rocvad::PrDeviceSelector* PrEndpointRequest::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::rocvad::PrDeviceSelector* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:rocvad.PrEndpointRequest.device)
  return _msg;
}
inline void PrEndpointRequest::set_allocated_device(::rocvad::PrDeviceSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.device_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.device_ = reinterpret_cast<::rocvad::PrDeviceSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrEndpointRequest.device)
}

// .rocvad.PrEndpointInfo endpoint = 2;
inline bool PrEndpointRequest::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline void PrEndpointRequest::clear_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endpoint_ != nullptr) _impl_.endpoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rocvad::PrEndpointInfo& PrEndpointRequest::_internal_endpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rocvad::PrEndpointInfo* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocvad::PrEndpointInfo&>(::rocvad::_PrEndpointInfo_default_instance_);
}
inline const ::rocvad::PrEndpointInfo& PrEndpointRequest::endpoint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointRequest.endpoint)
  return _internal_endpoint();
}
inline void PrEndpointRequest::unsafe_arena_set_allocated_endpoint(::rocvad::PrEndpointInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = reinterpret_cast<::rocvad::PrEndpointInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrEndpointRequest.endpoint)
}
inline ::rocvad::PrEndpointInfo* PrEndpointRequest::release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rocvad::PrEndpointInfo* released = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rocvad::PrEndpointInfo* PrEndpointRequest::unsafe_arena_release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrEndpointRequest.endpoint)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rocvad::PrEndpointInfo* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::rocvad::PrEndpointInfo* PrEndpointRequest::_internal_mutable_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endpoint_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::rocvad::PrEndpointInfo>(GetArena());
    _impl_.endpoint_ = reinterpret_cast<::rocvad::PrEndpointInfo*>(p);
  }
  return _impl_.endpoint_;
}
inline ::rocvad::PrEndpointInfo* PrEndpointRequest::mutable_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::rocvad::PrEndpointInfo* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:rocvad.PrEndpointRequest.endpoint)
  return _msg;
}
inline void PrEndpointRequest::set_allocated_endpoint(::rocvad::PrEndpointInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.endpoint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.endpoint_ = reinterpret_cast<::rocvad::PrEndpointInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrEndpointRequest.endpoint)
}

// -------------------------------------------------------------------

// PrEndpointInfo

// optional uint32 slot = 1;
inline bool PrEndpointInfo::has_slot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PrEndpointInfo::clear_slot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slot_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t PrEndpointInfo::slot() const {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointInfo.slot)
  return _internal_slot();
}
inline void PrEndpointInfo::set_slot(::uint32_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:rocvad.PrEndpointInfo.slot)
}
inline ::uint32_t PrEndpointInfo::_internal_slot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slot_;
}
inline void PrEndpointInfo::_internal_set_slot(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slot_ = value;
}

// .rocvad.PrInterface interface = 2;
inline void PrEndpointInfo::clear_interface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interface_ = 0;
}
inline ::rocvad::PrInterface PrEndpointInfo::interface() const {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointInfo.interface)
  return _internal_interface();
}
inline void PrEndpointInfo::set_interface(::rocvad::PrInterface value) {
  _internal_set_interface(value);
  // @@protoc_insertion_point(field_set:rocvad.PrEndpointInfo.interface)
}
inline ::rocvad::PrInterface PrEndpointInfo::_internal_interface() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrInterface>(_impl_.interface_);
}
inline void PrEndpointInfo::_internal_set_interface(::rocvad::PrInterface value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interface_ = value;
}

// string uri = 3;
inline void PrEndpointInfo::clear_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& PrEndpointInfo::uri() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointInfo.uri)
  return _internal_uri();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrEndpointInfo::set_uri(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uri_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rocvad.PrEndpointInfo.uri)
}
inline std::string* PrEndpointInfo::mutable_uri() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:rocvad.PrEndpointInfo.uri)
  return _s;
}
inline const std::string& PrEndpointInfo::_internal_uri() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uri_.Get();
}
inline void PrEndpointInfo::_internal_set_uri(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uri_.Set(value, GetArena());
}
inline std::string* PrEndpointInfo::_internal_mutable_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.uri_.Mutable( GetArena());
}
inline std::string* PrEndpointInfo::release_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrEndpointInfo.uri)
  return _impl_.uri_.Release();
}
inline void PrEndpointInfo::set_allocated_uri(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uri_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uri_.IsDefault()) {
          _impl_.uri_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrEndpointInfo.uri)
}

// -------------------------------------------------------------------

// PrLocalConfig

// optional uint32 sample_rate = 1;
inline bool PrLocalConfig::has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PrLocalConfig::clear_sample_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t PrLocalConfig::sample_rate() const {
  // @@protoc_insertion_point(field_get:rocvad.PrLocalConfig.sample_rate)
  return _internal_sample_rate();
}
inline void PrLocalConfig::set_sample_rate(::uint32_t value) {
  _internal_set_sample_rate(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:rocvad.PrLocalConfig.sample_rate)
}
inline ::uint32_t PrLocalConfig::_internal_sample_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_rate_;
}
inline void PrLocalConfig::_internal_set_sample_rate(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_ = value;
}

// optional .rocvad.PrChannelLayout channel_layout = 2;
inline bool PrLocalConfig::has_channel_layout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PrLocalConfig::clear_channel_layout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_layout_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::rocvad::PrChannelLayout PrLocalConfig::channel_layout() const {
  // @@protoc_insertion_point(field_get:rocvad.PrLocalConfig.channel_layout)
  return _internal_channel_layout();
}
inline void PrLocalConfig::set_channel_layout(::rocvad::PrChannelLayout value) {
  _internal_set_channel_layout(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:rocvad.PrLocalConfig.channel_layout)
}
inline ::rocvad::PrChannelLayout PrLocalConfig::_internal_channel_layout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrChannelLayout>(_impl_.channel_layout_);
}
inline void PrLocalConfig::_internal_set_channel_layout(::rocvad::PrChannelLayout value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_layout_ = value;
}

// -------------------------------------------------------------------

// PrSenderConfig

// optional .rocvad.PrPacketEncoding packet_encoding = 1;
inline bool PrSenderConfig::has_packet_encoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PrSenderConfig::clear_packet_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_encoding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::rocvad::PrPacketEncoding PrSenderConfig::packet_encoding() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.packet_encoding)
  return _internal_packet_encoding();
}
inline void PrSenderConfig::set_packet_encoding(::rocvad::PrPacketEncoding value) {
  _internal_set_packet_encoding(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.packet_encoding)
}
inline ::rocvad::PrPacketEncoding PrSenderConfig::_internal_packet_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrPacketEncoding>(_impl_.packet_encoding_);
}
inline void PrSenderConfig::_internal_set_packet_encoding(::rocvad::PrPacketEncoding value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_encoding_ = value;
}

// optional .google.protobuf.Duration packet_length = 2;
inline bool PrSenderConfig::has_packet_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_length_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& PrSenderConfig::_internal_packet_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.packet_length_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& PrSenderConfig::packet_length() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.packet_length)
  return _internal_packet_length();
}
inline void PrSenderConfig::unsafe_arena_set_allocated_packet_length(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.packet_length_);
  }
  _impl_.packet_length_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrSenderConfig.packet_length)
}
inline ::google::protobuf::Duration* PrSenderConfig::release_packet_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.packet_length_;
  _impl_.packet_length_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* PrSenderConfig::unsafe_arena_release_packet_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrSenderConfig.packet_length)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.packet_length_;
  _impl_.packet_length_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PrSenderConfig::_internal_mutable_packet_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.packet_length_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.packet_length_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.packet_length_;
}
inline ::google::protobuf::Duration* PrSenderConfig::mutable_packet_length() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_packet_length();
  // @@protoc_insertion_point(field_mutable:rocvad.PrSenderConfig.packet_length)
  return _msg;
}
inline void PrSenderConfig::set_allocated_packet_length(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.packet_length_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.packet_length_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrSenderConfig.packet_length)
}

// optional bool packet_interleaving = 3;
inline bool PrSenderConfig::has_packet_interleaving() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PrSenderConfig::clear_packet_interleaving() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_interleaving_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool PrSenderConfig::packet_interleaving() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.packet_interleaving)
  return _internal_packet_interleaving();
}
inline void PrSenderConfig::set_packet_interleaving(bool value) {
  _internal_set_packet_interleaving(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.packet_interleaving)
}
inline bool PrSenderConfig::_internal_packet_interleaving() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_interleaving_;
}
inline void PrSenderConfig::_internal_set_packet_interleaving(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_interleaving_ = value;
}

// optional .rocvad.PrFecEncoding fec_encoding = 4;
inline bool PrSenderConfig::has_fec_encoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void PrSenderConfig::clear_fec_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_encoding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::rocvad::PrFecEncoding PrSenderConfig::fec_encoding() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.fec_encoding)
  return _internal_fec_encoding();
}
inline void PrSenderConfig::set_fec_encoding(::rocvad::PrFecEncoding value) {
  _internal_set_fec_encoding(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.fec_encoding)
}
inline ::rocvad::PrFecEncoding PrSenderConfig::_internal_fec_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrFecEncoding>(_impl_.fec_encoding_);
}
inline void PrSenderConfig::_internal_set_fec_encoding(::rocvad::PrFecEncoding value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_encoding_ = value;
}

// optional uint32 fec_block_source_packets = 5;
inline bool PrSenderConfig::has_fec_block_source_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void PrSenderConfig::clear_fec_block_source_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_block_source_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t PrSenderConfig::fec_block_source_packets() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.fec_block_source_packets)
  return _internal_fec_block_source_packets();
}
inline void PrSenderConfig::set_fec_block_source_packets(::uint32_t value) {
  _internal_set_fec_block_source_packets(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.fec_block_source_packets)
}
inline ::uint32_t PrSenderConfig::_internal_fec_block_source_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fec_block_source_packets_;
}
inline void PrSenderConfig::_internal_set_fec_block_source_packets(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_block_source_packets_ = value;
}

// optional uint32 fec_block_repair_packets = 6;
inline bool PrSenderConfig::has_fec_block_repair_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void PrSenderConfig::clear_fec_block_repair_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_block_repair_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t PrSenderConfig::fec_block_repair_packets() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.fec_block_repair_packets)
  return _internal_fec_block_repair_packets();
}
inline void PrSenderConfig::set_fec_block_repair_packets(::uint32_t value) {
  _internal_set_fec_block_repair_packets(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.fec_block_repair_packets)
}
inline ::uint32_t PrSenderConfig::_internal_fec_block_repair_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fec_block_repair_packets_;
}
inline void PrSenderConfig::_internal_set_fec_block_repair_packets(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_block_repair_packets_ = value;
}

// optional .google.protobuf.Duration target_latency = 7;
inline bool PrSenderConfig::has_target_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_latency_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& PrSenderConfig::_internal_target_latency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.target_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& PrSenderConfig::target_latency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.target_latency)
  return _internal_target_latency();
}
inline void PrSenderConfig::unsafe_arena_set_allocated_target_latency(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_latency_);
  }
  _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrSenderConfig.target_latency)
}
inline ::google::protobuf::Duration* PrSenderConfig::release_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* PrSenderConfig::unsafe_arena_release_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrSenderConfig.target_latency)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PrSenderConfig::_internal_mutable_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_latency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.target_latency_;
}
inline ::google::protobuf::Duration* PrSenderConfig::mutable_target_latency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Duration* _msg = _internal_mutable_target_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrSenderConfig.target_latency)
  return _msg;
}
inline void PrSenderConfig::set_allocated_target_latency(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_latency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrSenderConfig.target_latency)
}

// optional .google.protobuf.Duration min_latency = 8;
inline bool PrSenderConfig::has_min_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_latency_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& PrSenderConfig::_internal_min_latency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.min_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& PrSenderConfig::min_latency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.min_latency)
  return _internal_min_latency();
}
inline void PrSenderConfig::unsafe_arena_set_allocated_min_latency(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_latency_);
  }
  _impl_.min_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrSenderConfig.min_latency)
}
inline ::google::protobuf::Duration* PrSenderConfig::release_min_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* released = _impl_.min_latency_;
  _impl_.min_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* PrSenderConfig::unsafe_arena_release_min_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrSenderConfig.min_latency)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* temp = _impl_.min_latency_;
  _impl_.min_latency_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PrSenderConfig::_internal_mutable_min_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.min_latency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.min_latency_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.min_latency_;
}
inline ::google::protobuf::Duration* PrSenderConfig::mutable_min_latency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Duration* _msg = _internal_mutable_min_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrSenderConfig.min_latency)
  return _msg;
}
inline void PrSenderConfig::set_allocated_min_latency(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_latency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.min_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrSenderConfig.min_latency)
}

// optional .google.protobuf.Duration max_latency = 9;
inline bool PrSenderConfig::has_max_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_latency_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& PrSenderConfig::_internal_max_latency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.max_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& PrSenderConfig::max_latency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.max_latency)
  return _internal_max_latency();
}
inline void PrSenderConfig::unsafe_arena_set_allocated_max_latency(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_latency_);
  }
  _impl_.max_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrSenderConfig.max_latency)
}
inline ::google::protobuf::Duration* PrSenderConfig::release_max_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* released = _impl_.max_latency_;
  _impl_.max_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* PrSenderConfig::unsafe_arena_release_max_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrSenderConfig.max_latency)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* temp = _impl_.max_latency_;
  _impl_.max_latency_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PrSenderConfig::_internal_mutable_max_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.max_latency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.max_latency_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.max_latency_;
}
inline ::google::protobuf::Duration* PrSenderConfig::mutable_max_latency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Duration* _msg = _internal_mutable_max_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrSenderConfig.max_latency)
  return _msg;
}
inline void PrSenderConfig::set_allocated_max_latency(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_latency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.max_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrSenderConfig.max_latency)
}

// optional .rocvad.PrLatencyTunerBackend latency_tuner_backend = 10;
inline bool PrSenderConfig::has_latency_tuner_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void PrSenderConfig::clear_latency_tuner_backend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::rocvad::PrLatencyTunerBackend PrSenderConfig::latency_tuner_backend() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.latency_tuner_backend)
  return _internal_latency_tuner_backend();
}
inline void PrSenderConfig::set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value) {
  _internal_set_latency_tuner_backend(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.latency_tuner_backend)
}
inline ::rocvad::PrLatencyTunerBackend PrSenderConfig::_internal_latency_tuner_backend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrLatencyTunerBackend>(_impl_.latency_tuner_backend_);
}
inline void PrSenderConfig::_internal_set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_backend_ = value;
}

// optional .rocvad.PrLatencyTunerProfile latency_tuner_profile = 11;
inline bool PrSenderConfig::has_latency_tuner_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void PrSenderConfig::clear_latency_tuner_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::rocvad::PrLatencyTunerProfile PrSenderConfig::latency_tuner_profile() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.latency_tuner_profile)
  return _internal_latency_tuner_profile();
}
inline void PrSenderConfig::set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value) {
  _internal_set_latency_tuner_profile(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.latency_tuner_profile)
}
inline ::rocvad::PrLatencyTunerProfile PrSenderConfig::_internal_latency_tuner_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrLatencyTunerProfile>(_impl_.latency_tuner_profile_);
}
inline void PrSenderConfig::_internal_set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_profile_ = value;
}

// optional .rocvad.PrResamplerBackend resampler_backend = 12;
inline bool PrSenderConfig::has_resampler_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void PrSenderConfig::clear_resampler_backend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::rocvad::PrResamplerBackend PrSenderConfig::resampler_backend() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.resampler_backend)
  return _internal_resampler_backend();
}
inline void PrSenderConfig::set_resampler_backend(::rocvad::PrResamplerBackend value) {
  _internal_set_resampler_backend(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.resampler_backend)
}
inline ::rocvad::PrResamplerBackend PrSenderConfig::_internal_resampler_backend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrResamplerBackend>(_impl_.resampler_backend_);
}
inline void PrSenderConfig::_internal_set_resampler_backend(::rocvad::PrResamplerBackend value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_backend_ = value;
}

// optional .rocvad.PrResamplerProfile resampler_profile = 13;
inline bool PrSenderConfig::has_resampler_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void PrSenderConfig::clear_resampler_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::rocvad::PrResamplerProfile PrSenderConfig::resampler_profile() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.resampler_profile)
  return _internal_resampler_profile();
}
inline void PrSenderConfig::set_resampler_profile(::rocvad::PrResamplerProfile value) {
  _internal_set_resampler_profile(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.resampler_profile)
}
inline ::rocvad::PrResamplerProfile PrSenderConfig::_internal_resampler_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrResamplerProfile>(_impl_.resampler_profile_);
}
inline void PrSenderConfig::_internal_set_resampler_profile(::rocvad::PrResamplerProfile value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_profile_ = value;
}

// -------------------------------------------------------------------

// PrReceiverConfig

// optional .google.protobuf.Duration target_latency = 1;
inline bool PrReceiverConfig::has_target_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_latency_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& PrReceiverConfig::_internal_target_latency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.target_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& PrReceiverConfig::target_latency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.target_latency)
  return _internal_target_latency();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_target_latency(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_latency_);
  }
  _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.target_latency)
}
inline ::google::protobuf::Duration* PrReceiverConfig::release_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* PrReceiverConfig::unsafe_arena_release_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.target_latency)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PrReceiverConfig::_internal_mutable_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_latency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.target_latency_;
}
inline ::google::protobuf::Duration* PrReceiverConfig::mutable_target_latency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_target_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.target_latency)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_target_latency(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_latency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.target_latency)
}

// optional .google.protobuf.Duration min_latency = 2;
inline bool PrReceiverConfig::has_min_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_latency_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& PrReceiverConfig::_internal_min_latency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.min_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& PrReceiverConfig::min_latency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.min_latency)
  return _internal_min_latency();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_min_latency(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_latency_);
  }
  _impl_.min_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.min_latency)
}
inline ::google::protobuf::Duration* PrReceiverConfig::release_min_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.min_latency_;
  _impl_.min_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* PrReceiverConfig::unsafe_arena_release_min_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.min_latency)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.min_latency_;
  _impl_.min_latency_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PrReceiverConfig::_internal_mutable_min_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.min_latency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.min_latency_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.min_latency_;
}
inline ::google::protobuf::Duration* PrReceiverConfig::mutable_min_latency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Duration* _msg = _internal_mutable_min_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.min_latency)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_min_latency(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_latency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.min_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.min_latency)
}

// optional .google.protobuf.Duration max_latency = 3;
inline bool PrReceiverConfig::has_max_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_latency_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& PrReceiverConfig::_internal_max_latency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.max_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& PrReceiverConfig::max_latency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.max_latency)
  return _internal_max_latency();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_max_latency(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_latency_);
  }
  _impl_.max_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.max_latency)
}
inline ::google::protobuf::Duration* PrReceiverConfig::release_max_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* released = _impl_.max_latency_;
  _impl_.max_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* PrReceiverConfig::unsafe_arena_release_max_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.max_latency)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* temp = _impl_.max_latency_;
  _impl_.max_latency_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PrReceiverConfig::_internal_mutable_max_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.max_latency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.max_latency_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.max_latency_;
}
inline ::google::protobuf::Duration* PrReceiverConfig::mutable_max_latency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Duration* _msg = _internal_mutable_max_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.max_latency)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_max_latency(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_latency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.max_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.max_latency)
}

// optional .rocvad.PrLatencyTunerBackend latency_tuner_backend = 4;
inline bool PrReceiverConfig::has_latency_tuner_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PrReceiverConfig::clear_latency_tuner_backend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::rocvad::PrLatencyTunerBackend PrReceiverConfig::latency_tuner_backend() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.latency_tuner_backend)
  return _internal_latency_tuner_backend();
}
inline void PrReceiverConfig::set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value) {
  _internal_set_latency_tuner_backend(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:rocvad.PrReceiverConfig.latency_tuner_backend)
}
inline ::rocvad::PrLatencyTunerBackend PrReceiverConfig::_internal_latency_tuner_backend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrLatencyTunerBackend>(_impl_.latency_tuner_backend_);
}
inline void PrReceiverConfig::_internal_set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_backend_ = value;
}

// optional .rocvad.PrLatencyTunerProfile latency_tuner_profile = 5;
inline bool PrReceiverConfig::has_latency_tuner_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void PrReceiverConfig::clear_latency_tuner_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::rocvad::PrLatencyTunerProfile PrReceiverConfig::latency_tuner_profile() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.latency_tuner_profile)
  return _internal_latency_tuner_profile();
}
inline void PrReceiverConfig::set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value) {
  _internal_set_latency_tuner_profile(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:rocvad.PrReceiverConfig.latency_tuner_profile)
}
inline ::rocvad::PrLatencyTunerProfile PrReceiverConfig::_internal_latency_tuner_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrLatencyTunerProfile>(_impl_.latency_tuner_profile_);
}
inline void PrReceiverConfig::_internal_set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_profile_ = value;
}

// optional .rocvad.PrResamplerBackend resampler_backend = 6;
inline bool PrReceiverConfig::has_resampler_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void PrReceiverConfig::clear_resampler_backend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::rocvad::PrResamplerBackend PrReceiverConfig::resampler_backend() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.resampler_backend)
  return _internal_resampler_backend();
}
inline void PrReceiverConfig::set_resampler_backend(::rocvad::PrResamplerBackend value) {
  _internal_set_resampler_backend(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:rocvad.PrReceiverConfig.resampler_backend)
}
inline ::rocvad::PrResamplerBackend PrReceiverConfig::_internal_resampler_backend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrResamplerBackend>(_impl_.resampler_backend_);
}
inline void PrReceiverConfig::_internal_set_resampler_backend(::rocvad::PrResamplerBackend value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_backend_ = value;
}

// optional .rocvad.PrResamplerProfile resampler_profile = 7;
inline bool PrReceiverConfig::has_resampler_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void PrReceiverConfig::clear_resampler_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::rocvad::PrResamplerProfile PrReceiverConfig::resampler_profile() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.resampler_profile)
  return _internal_resampler_profile();
}
inline void PrReceiverConfig::set_resampler_profile(::rocvad::PrResamplerProfile value) {
  _internal_set_resampler_profile(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:rocvad.PrReceiverConfig.resampler_profile)
}
inline ::rocvad::PrResamplerProfile PrReceiverConfig::_internal_resampler_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rocvad::PrResamplerProfile>(_impl_.resampler_profile_);
}
inline void PrReceiverConfig::_internal_set_resampler_profile(::rocvad::PrResamplerProfile value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_profile_ = value;
}

// optional .google.protobuf.Duration no_playback_timeout = 8;
inline bool PrReceiverConfig::has_no_playback_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.no_playback_timeout_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& PrReceiverConfig::_internal_no_playback_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.no_playback_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& PrReceiverConfig::no_playback_timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.no_playback_timeout)
  return _internal_no_playback_timeout();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_no_playback_timeout(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.no_playback_timeout_);
  }
  _impl_.no_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.no_playback_timeout)
}
inline ::google::protobuf::Duration* PrReceiverConfig::release_no_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* released = _impl_.no_playback_timeout_;
  _impl_.no_playback_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* PrReceiverConfig::unsafe_arena_release_no_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.no_playback_timeout)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* temp = _impl_.no_playback_timeout_;
  _impl_.no_playback_timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PrReceiverConfig::_internal_mutable_no_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.no_playback_timeout_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.no_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.no_playback_timeout_;
}
inline ::google::protobuf::Duration* PrReceiverConfig::mutable_no_playback_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Duration* _msg = _internal_mutable_no_playback_timeout();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.no_playback_timeout)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_no_playback_timeout(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.no_playback_timeout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.no_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.no_playback_timeout)
}

// optional .google.protobuf.Duration choppy_playback_timeout = 9;
inline bool PrReceiverConfig::has_choppy_playback_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.choppy_playback_timeout_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& PrReceiverConfig::_internal_choppy_playback_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.choppy_playback_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& PrReceiverConfig::choppy_playback_timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.choppy_playback_timeout)
  return _internal_choppy_playback_timeout();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_choppy_playback_timeout(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.choppy_playback_timeout_);
  }
  _impl_.choppy_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.choppy_playback_timeout)
}
inline ::google::protobuf::Duration* PrReceiverConfig::release_choppy_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Duration* released = _impl_.choppy_playback_timeout_;
  _impl_.choppy_playback_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* PrReceiverConfig::unsafe_arena_release_choppy_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.choppy_playback_timeout)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Duration* temp = _impl_.choppy_playback_timeout_;
  _impl_.choppy_playback_timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PrReceiverConfig::_internal_mutable_choppy_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.choppy_playback_timeout_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.choppy_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.choppy_playback_timeout_;
}
inline ::google::protobuf::Duration* PrReceiverConfig::mutable_choppy_playback_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::Duration* _msg = _internal_mutable_choppy_playback_timeout();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.choppy_playback_timeout)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_choppy_playback_timeout(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.choppy_playback_timeout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.choppy_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.choppy_playback_timeout)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace rocvad


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::rocvad::PrLogEntry_Level> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrLogEntry_Level>() {
  return ::rocvad::PrLogEntry_Level_descriptor();
}
template <>
struct is_proto_enum<::rocvad::PrDeviceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrDeviceType>() {
  return ::rocvad::PrDeviceType_descriptor();
}
template <>
struct is_proto_enum<::rocvad::PrInterface> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrInterface>() {
  return ::rocvad::PrInterface_descriptor();
}
template <>
struct is_proto_enum<::rocvad::PrChannelLayout> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrChannelLayout>() {
  return ::rocvad::PrChannelLayout_descriptor();
}
template <>
struct is_proto_enum<::rocvad::PrPacketEncoding> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrPacketEncoding>() {
  return ::rocvad::PrPacketEncoding_descriptor();
}
template <>
struct is_proto_enum<::rocvad::PrFecEncoding> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrFecEncoding>() {
  return ::rocvad::PrFecEncoding_descriptor();
}
template <>
struct is_proto_enum<::rocvad::PrLatencyTunerBackend> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrLatencyTunerBackend>() {
  return ::rocvad::PrLatencyTunerBackend_descriptor();
}
template <>
struct is_proto_enum<::rocvad::PrLatencyTunerProfile> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrLatencyTunerProfile>() {
  return ::rocvad::PrLatencyTunerProfile_descriptor();
}
template <>
struct is_proto_enum<::rocvad::PrResamplerBackend> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrResamplerBackend>() {
  return ::rocvad::PrResamplerBackend_descriptor();
}
template <>
struct is_proto_enum<::rocvad::PrResamplerProfile> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rocvad::PrResamplerProfile>() {
  return ::rocvad::PrResamplerProfile_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_driver_5fprotocol_2eproto_2epb_2eh
