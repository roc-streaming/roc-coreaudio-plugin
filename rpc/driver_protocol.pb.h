// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: driver_protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_driver_5fprotocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_driver_5fprotocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_driver_5fprotocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_driver_5fprotocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_driver_5fprotocol_2eproto;
namespace rocvad {
class PrDeviceInfo;
struct PrDeviceInfoDefaultTypeInternal;
extern PrDeviceInfoDefaultTypeInternal _PrDeviceInfo_default_instance_;
class PrDeviceList;
struct PrDeviceListDefaultTypeInternal;
extern PrDeviceListDefaultTypeInternal _PrDeviceList_default_instance_;
class PrDeviceSelector;
struct PrDeviceSelectorDefaultTypeInternal;
extern PrDeviceSelectorDefaultTypeInternal _PrDeviceSelector_default_instance_;
class PrDriverInfo;
struct PrDriverInfoDefaultTypeInternal;
extern PrDriverInfoDefaultTypeInternal _PrDriverInfo_default_instance_;
class PrEndpointInfo;
struct PrEndpointInfoDefaultTypeInternal;
extern PrEndpointInfoDefaultTypeInternal _PrEndpointInfo_default_instance_;
class PrEndpointRequest;
struct PrEndpointRequestDefaultTypeInternal;
extern PrEndpointRequestDefaultTypeInternal _PrEndpointRequest_default_instance_;
class PrLocalConfig;
struct PrLocalConfigDefaultTypeInternal;
extern PrLocalConfigDefaultTypeInternal _PrLocalConfig_default_instance_;
class PrLogEntry;
struct PrLogEntryDefaultTypeInternal;
extern PrLogEntryDefaultTypeInternal _PrLogEntry_default_instance_;
class PrNone;
struct PrNoneDefaultTypeInternal;
extern PrNoneDefaultTypeInternal _PrNone_default_instance_;
class PrReceiverConfig;
struct PrReceiverConfigDefaultTypeInternal;
extern PrReceiverConfigDefaultTypeInternal _PrReceiverConfig_default_instance_;
class PrSenderConfig;
struct PrSenderConfigDefaultTypeInternal;
extern PrSenderConfigDefaultTypeInternal _PrSenderConfig_default_instance_;
}  // namespace rocvad
PROTOBUF_NAMESPACE_OPEN
template<> ::rocvad::PrDeviceInfo* Arena::CreateMaybeMessage<::rocvad::PrDeviceInfo>(Arena*);
template<> ::rocvad::PrDeviceList* Arena::CreateMaybeMessage<::rocvad::PrDeviceList>(Arena*);
template<> ::rocvad::PrDeviceSelector* Arena::CreateMaybeMessage<::rocvad::PrDeviceSelector>(Arena*);
template<> ::rocvad::PrDriverInfo* Arena::CreateMaybeMessage<::rocvad::PrDriverInfo>(Arena*);
template<> ::rocvad::PrEndpointInfo* Arena::CreateMaybeMessage<::rocvad::PrEndpointInfo>(Arena*);
template<> ::rocvad::PrEndpointRequest* Arena::CreateMaybeMessage<::rocvad::PrEndpointRequest>(Arena*);
template<> ::rocvad::PrLocalConfig* Arena::CreateMaybeMessage<::rocvad::PrLocalConfig>(Arena*);
template<> ::rocvad::PrLogEntry* Arena::CreateMaybeMessage<::rocvad::PrLogEntry>(Arena*);
template<> ::rocvad::PrNone* Arena::CreateMaybeMessage<::rocvad::PrNone>(Arena*);
template<> ::rocvad::PrReceiverConfig* Arena::CreateMaybeMessage<::rocvad::PrReceiverConfig>(Arena*);
template<> ::rocvad::PrSenderConfig* Arena::CreateMaybeMessage<::rocvad::PrSenderConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rocvad {

enum PrLogEntry_Level : int {
  PrLogEntry_Level_CRIT = 0,
  PrLogEntry_Level_ERROR = 1,
  PrLogEntry_Level_WARN = 2,
  PrLogEntry_Level_INFO = 3,
  PrLogEntry_Level_DEBUG = 4,
  PrLogEntry_Level_TRACE = 5,
  PrLogEntry_Level_PrLogEntry_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrLogEntry_Level_PrLogEntry_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrLogEntry_Level_IsValid(int value);
constexpr PrLogEntry_Level PrLogEntry_Level_Level_MIN = PrLogEntry_Level_CRIT;
constexpr PrLogEntry_Level PrLogEntry_Level_Level_MAX = PrLogEntry_Level_TRACE;
constexpr int PrLogEntry_Level_Level_ARRAYSIZE = PrLogEntry_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrLogEntry_Level_descriptor();
template<typename T>
inline const std::string& PrLogEntry_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrLogEntry_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrLogEntry_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrLogEntry_Level_descriptor(), enum_t_value);
}
inline bool PrLogEntry_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrLogEntry_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrLogEntry_Level>(
    PrLogEntry_Level_descriptor(), name, value);
}
enum PrDeviceType : int {
  PR_DEVICE_TYPE_SENDER = 0,
  PR_DEVICE_TYPE_RECEIVER = 1,
  PrDeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrDeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrDeviceType_IsValid(int value);
constexpr PrDeviceType PrDeviceType_MIN = PR_DEVICE_TYPE_SENDER;
constexpr PrDeviceType PrDeviceType_MAX = PR_DEVICE_TYPE_RECEIVER;
constexpr int PrDeviceType_ARRAYSIZE = PrDeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrDeviceType_descriptor();
template<typename T>
inline const std::string& PrDeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrDeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrDeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrDeviceType_descriptor(), enum_t_value);
}
inline bool PrDeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrDeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrDeviceType>(
    PrDeviceType_descriptor(), name, value);
}
enum PrInterface : int {
  PR_INTERFACE_CONSOLIDATED = 0,
  PR_INTERFACE_AUDIO_SOURCE = 1,
  PR_INTERFACE_AUDIO_REPAIR = 2,
  PR_INTERFACE_AUDIO_CONTROL = 3,
  PrInterface_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrInterface_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrInterface_IsValid(int value);
constexpr PrInterface PrInterface_MIN = PR_INTERFACE_CONSOLIDATED;
constexpr PrInterface PrInterface_MAX = PR_INTERFACE_AUDIO_CONTROL;
constexpr int PrInterface_ARRAYSIZE = PrInterface_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrInterface_descriptor();
template<typename T>
inline const std::string& PrInterface_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrInterface>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrInterface_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrInterface_descriptor(), enum_t_value);
}
inline bool PrInterface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrInterface* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrInterface>(
    PrInterface_descriptor(), name, value);
}
enum PrChannelLayout : int {
  PR_CHANNEL_LAYOUT_MONO = 0,
  PR_CHANNEL_LAYOUT_STEREO = 1,
  PrChannelLayout_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrChannelLayout_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrChannelLayout_IsValid(int value);
constexpr PrChannelLayout PrChannelLayout_MIN = PR_CHANNEL_LAYOUT_MONO;
constexpr PrChannelLayout PrChannelLayout_MAX = PR_CHANNEL_LAYOUT_STEREO;
constexpr int PrChannelLayout_ARRAYSIZE = PrChannelLayout_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrChannelLayout_descriptor();
template<typename T>
inline const std::string& PrChannelLayout_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrChannelLayout>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrChannelLayout_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrChannelLayout_descriptor(), enum_t_value);
}
inline bool PrChannelLayout_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrChannelLayout* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrChannelLayout>(
    PrChannelLayout_descriptor(), name, value);
}
enum PrPacketEncoding : int {
  PR_PACKET_ENCODING_AVP_L16_MONO = 0,
  PR_PACKET_ENCODING_AVP_L16_STEREO = 1,
  PrPacketEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrPacketEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrPacketEncoding_IsValid(int value);
constexpr PrPacketEncoding PrPacketEncoding_MIN = PR_PACKET_ENCODING_AVP_L16_MONO;
constexpr PrPacketEncoding PrPacketEncoding_MAX = PR_PACKET_ENCODING_AVP_L16_STEREO;
constexpr int PrPacketEncoding_ARRAYSIZE = PrPacketEncoding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrPacketEncoding_descriptor();
template<typename T>
inline const std::string& PrPacketEncoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrPacketEncoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrPacketEncoding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrPacketEncoding_descriptor(), enum_t_value);
}
inline bool PrPacketEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrPacketEncoding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrPacketEncoding>(
    PrPacketEncoding_descriptor(), name, value);
}
enum PrFecEncoding : int {
  PR_FEC_ENCODING_DISABLE = 0,
  PR_FEC_ENCODING_RS8M = 1,
  PR_FEC_ENCODING_LDPC_STAIRCASE = 2,
  PrFecEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrFecEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrFecEncoding_IsValid(int value);
constexpr PrFecEncoding PrFecEncoding_MIN = PR_FEC_ENCODING_DISABLE;
constexpr PrFecEncoding PrFecEncoding_MAX = PR_FEC_ENCODING_LDPC_STAIRCASE;
constexpr int PrFecEncoding_ARRAYSIZE = PrFecEncoding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrFecEncoding_descriptor();
template<typename T>
inline const std::string& PrFecEncoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrFecEncoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrFecEncoding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrFecEncoding_descriptor(), enum_t_value);
}
inline bool PrFecEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrFecEncoding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrFecEncoding>(
    PrFecEncoding_descriptor(), name, value);
}
enum PrLatencyTunerBackend : int {
  PR_LATENCY_TUNER_BACKEND_DEFAULT = 0,
  PR_LATENCY_TUNER_BACKEND_NIQ = 2,
  PrLatencyTunerBackend_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrLatencyTunerBackend_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrLatencyTunerBackend_IsValid(int value);
constexpr PrLatencyTunerBackend PrLatencyTunerBackend_MIN = PR_LATENCY_TUNER_BACKEND_DEFAULT;
constexpr PrLatencyTunerBackend PrLatencyTunerBackend_MAX = PR_LATENCY_TUNER_BACKEND_NIQ;
constexpr int PrLatencyTunerBackend_ARRAYSIZE = PrLatencyTunerBackend_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrLatencyTunerBackend_descriptor();
template<typename T>
inline const std::string& PrLatencyTunerBackend_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrLatencyTunerBackend>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrLatencyTunerBackend_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrLatencyTunerBackend_descriptor(), enum_t_value);
}
inline bool PrLatencyTunerBackend_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrLatencyTunerBackend* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrLatencyTunerBackend>(
    PrLatencyTunerBackend_descriptor(), name, value);
}
enum PrLatencyTunerProfile : int {
  PR_LATENCY_TUNER_PROFILE_DEFAULT = 0,
  PR_LATENCY_TUNER_PROFILE_INTACT = 1,
  PR_LATENCY_TUNER_PROFILE_RESPONSIVE = 2,
  PR_LATENCY_TUNER_PROFILE_GRADUAL = 3,
  PrLatencyTunerProfile_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrLatencyTunerProfile_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrLatencyTunerProfile_IsValid(int value);
constexpr PrLatencyTunerProfile PrLatencyTunerProfile_MIN = PR_LATENCY_TUNER_PROFILE_DEFAULT;
constexpr PrLatencyTunerProfile PrLatencyTunerProfile_MAX = PR_LATENCY_TUNER_PROFILE_GRADUAL;
constexpr int PrLatencyTunerProfile_ARRAYSIZE = PrLatencyTunerProfile_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrLatencyTunerProfile_descriptor();
template<typename T>
inline const std::string& PrLatencyTunerProfile_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrLatencyTunerProfile>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrLatencyTunerProfile_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrLatencyTunerProfile_descriptor(), enum_t_value);
}
inline bool PrLatencyTunerProfile_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrLatencyTunerProfile* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrLatencyTunerProfile>(
    PrLatencyTunerProfile_descriptor(), name, value);
}
enum PrResamplerBackend : int {
  PR_RESAMPLER_BACKEND_DEFAULT = 0,
  PR_RESAMPLER_BACKEND_BUILTIN = 1,
  PR_RESAMPLER_BACKEND_SPEEX = 2,
  PR_RESAMPLER_BACKEND_SPEEXDEC = 3,
  PrResamplerBackend_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrResamplerBackend_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrResamplerBackend_IsValid(int value);
constexpr PrResamplerBackend PrResamplerBackend_MIN = PR_RESAMPLER_BACKEND_DEFAULT;
constexpr PrResamplerBackend PrResamplerBackend_MAX = PR_RESAMPLER_BACKEND_SPEEXDEC;
constexpr int PrResamplerBackend_ARRAYSIZE = PrResamplerBackend_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrResamplerBackend_descriptor();
template<typename T>
inline const std::string& PrResamplerBackend_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrResamplerBackend>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrResamplerBackend_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrResamplerBackend_descriptor(), enum_t_value);
}
inline bool PrResamplerBackend_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrResamplerBackend* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrResamplerBackend>(
    PrResamplerBackend_descriptor(), name, value);
}
enum PrResamplerProfile : int {
  PR_RESAMPLER_PROFILE_DEFAULT = 0,
  PR_RESAMPLER_PROFILE_HIGH = 1,
  PR_RESAMPLER_PROFILE_MEDIUM = 2,
  PR_RESAMPLER_PROFILE_LOW = 3,
  PrResamplerProfile_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrResamplerProfile_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrResamplerProfile_IsValid(int value);
constexpr PrResamplerProfile PrResamplerProfile_MIN = PR_RESAMPLER_PROFILE_DEFAULT;
constexpr PrResamplerProfile PrResamplerProfile_MAX = PR_RESAMPLER_PROFILE_LOW;
constexpr int PrResamplerProfile_ARRAYSIZE = PrResamplerProfile_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrResamplerProfile_descriptor();
template<typename T>
inline const std::string& PrResamplerProfile_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrResamplerProfile>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrResamplerProfile_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrResamplerProfile_descriptor(), enum_t_value);
}
inline bool PrResamplerProfile_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrResamplerProfile* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrResamplerProfile>(
    PrResamplerProfile_descriptor(), name, value);
}
// ===================================================================

class PrNone final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rocvad.PrNone) */ {
 public:
  inline PrNone() : PrNone(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PrNone(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrNone(const PrNone& from);
  PrNone(PrNone&& from) noexcept
    : PrNone() {
    *this = ::std::move(from);
  }

  inline PrNone& operator=(const PrNone& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrNone& operator=(PrNone&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrNone& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrNone* internal_default_instance() {
    return reinterpret_cast<const PrNone*>(
               &_PrNone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PrNone& a, PrNone& b) {
    a.Swap(&b);
  }
  inline void Swap(PrNone* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrNone* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrNone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrNone>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PrNone& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PrNone& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrNone";
  }
  protected:
  explicit PrNone(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rocvad.PrNone)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrDriverInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrDriverInfo) */ {
 public:
  inline PrDriverInfo() : PrDriverInfo(nullptr) {}
  ~PrDriverInfo() override;
  explicit PROTOBUF_CONSTEXPR PrDriverInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrDriverInfo(const PrDriverInfo& from);
  PrDriverInfo(PrDriverInfo&& from) noexcept
    : PrDriverInfo() {
    *this = ::std::move(from);
  }

  inline PrDriverInfo& operator=(const PrDriverInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrDriverInfo& operator=(PrDriverInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrDriverInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrDriverInfo* internal_default_instance() {
    return reinterpret_cast<const PrDriverInfo*>(
               &_PrDriverInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PrDriverInfo& a, PrDriverInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PrDriverInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrDriverInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrDriverInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrDriverInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrDriverInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrDriverInfo& from) {
    PrDriverInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrDriverInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrDriverInfo";
  }
  protected:
  explicit PrDriverInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kCommitFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string commit = 2;
  void clear_commit();
  const std::string& commit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commit();
  PROTOBUF_NODISCARD std::string* release_commit();
  void set_allocated_commit(std::string* commit);
  private:
  const std::string& _internal_commit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commit(const std::string& value);
  std::string* _internal_mutable_commit();
  public:

  // @@protoc_insertion_point(class_scope:rocvad.PrDriverInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrLogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrLogEntry) */ {
 public:
  inline PrLogEntry() : PrLogEntry(nullptr) {}
  ~PrLogEntry() override;
  explicit PROTOBUF_CONSTEXPR PrLogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrLogEntry(const PrLogEntry& from);
  PrLogEntry(PrLogEntry&& from) noexcept
    : PrLogEntry() {
    *this = ::std::move(from);
  }

  inline PrLogEntry& operator=(const PrLogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrLogEntry& operator=(PrLogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrLogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrLogEntry* internal_default_instance() {
    return reinterpret_cast<const PrLogEntry*>(
               &_PrLogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PrLogEntry& a, PrLogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(PrLogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrLogEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrLogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrLogEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrLogEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrLogEntry& from) {
    PrLogEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrLogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrLogEntry";
  }
  protected:
  explicit PrLogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PrLogEntry_Level Level;
  static constexpr Level CRIT =
    PrLogEntry_Level_CRIT;
  static constexpr Level ERROR =
    PrLogEntry_Level_ERROR;
  static constexpr Level WARN =
    PrLogEntry_Level_WARN;
  static constexpr Level INFO =
    PrLogEntry_Level_INFO;
  static constexpr Level DEBUG =
    PrLogEntry_Level_DEBUG;
  static constexpr Level TRACE =
    PrLogEntry_Level_TRACE;
  static inline bool Level_IsValid(int value) {
    return PrLogEntry_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    PrLogEntry_Level_Level_MIN;
  static constexpr Level Level_MAX =
    PrLogEntry_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    PrLogEntry_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return PrLogEntry_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return PrLogEntry_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return PrLogEntry_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kTimeFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // string text = 3;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // .rocvad.PrLogEntry.Level level = 2;
  void clear_level();
  ::rocvad::PrLogEntry_Level level() const;
  void set_level(::rocvad::PrLogEntry_Level value);
  private:
  ::rocvad::PrLogEntry_Level _internal_level() const;
  void _internal_set_level(::rocvad::PrLogEntry_Level value);
  public:

  // @@protoc_insertion_point(class_scope:rocvad.PrLogEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrDeviceSelector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrDeviceSelector) */ {
 public:
  inline PrDeviceSelector() : PrDeviceSelector(nullptr) {}
  ~PrDeviceSelector() override;
  explicit PROTOBUF_CONSTEXPR PrDeviceSelector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrDeviceSelector(const PrDeviceSelector& from);
  PrDeviceSelector(PrDeviceSelector&& from) noexcept
    : PrDeviceSelector() {
    *this = ::std::move(from);
  }

  inline PrDeviceSelector& operator=(const PrDeviceSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrDeviceSelector& operator=(PrDeviceSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrDeviceSelector& default_instance() {
    return *internal_default_instance();
  }
  enum SelectorCase {
    kIndex = 1,
    kUid = 2,
    SELECTOR_NOT_SET = 0,
  };

  static inline const PrDeviceSelector* internal_default_instance() {
    return reinterpret_cast<const PrDeviceSelector*>(
               &_PrDeviceSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PrDeviceSelector& a, PrDeviceSelector& b) {
    a.Swap(&b);
  }
  inline void Swap(PrDeviceSelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrDeviceSelector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrDeviceSelector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrDeviceSelector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrDeviceSelector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrDeviceSelector& from) {
    PrDeviceSelector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrDeviceSelector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrDeviceSelector";
  }
  protected:
  explicit PrDeviceSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kUidFieldNumber = 2,
  };
  // uint32 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // string uid = 2;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  void clear_Selector();
  SelectorCase Selector_case() const;
  // @@protoc_insertion_point(class_scope:rocvad.PrDeviceSelector)
 private:
  class _Internal;
  void set_has_index();
  void set_has_uid();

  inline bool has_Selector() const;
  inline void clear_has_Selector();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SelectorUnion {
      constexpr SelectorUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t index_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    } Selector_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrDeviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrDeviceInfo) */ {
 public:
  inline PrDeviceInfo() : PrDeviceInfo(nullptr) {}
  ~PrDeviceInfo() override;
  explicit PROTOBUF_CONSTEXPR PrDeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrDeviceInfo(const PrDeviceInfo& from);
  PrDeviceInfo(PrDeviceInfo&& from) noexcept
    : PrDeviceInfo() {
    *this = ::std::move(from);
  }

  inline PrDeviceInfo& operator=(const PrDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrDeviceInfo& operator=(PrDeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrDeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  enum NetworkConfigCase {
    kSenderConfig = 6,
    kReceiverConfig = 7,
    NETWORKCONFIG_NOT_SET = 0,
  };

  static inline const PrDeviceInfo* internal_default_instance() {
    return reinterpret_cast<const PrDeviceInfo*>(
               &_PrDeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PrDeviceInfo& a, PrDeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PrDeviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrDeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrDeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrDeviceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrDeviceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrDeviceInfo& from) {
    PrDeviceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrDeviceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrDeviceInfo";
  }
  protected:
  explicit PrDeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalEndpointsFieldNumber = 8,
    kRemoteEndpointsFieldNumber = 9,
    kUidFieldNumber = 3,
    kNameFieldNumber = 4,
    kLocalConfigFieldNumber = 5,
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 2,
    kSenderConfigFieldNumber = 6,
    kReceiverConfigFieldNumber = 7,
  };
  // repeated .rocvad.PrEndpointInfo local_endpoints = 8;
  int local_endpoints_size() const;
  private:
  int _internal_local_endpoints_size() const;
  public:
  void clear_local_endpoints();
  ::rocvad::PrEndpointInfo* mutable_local_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo >*
      mutable_local_endpoints();
  private:
  const ::rocvad::PrEndpointInfo& _internal_local_endpoints(int index) const;
  ::rocvad::PrEndpointInfo* _internal_add_local_endpoints();
  public:
  const ::rocvad::PrEndpointInfo& local_endpoints(int index) const;
  ::rocvad::PrEndpointInfo* add_local_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo >&
      local_endpoints() const;

  // repeated .rocvad.PrEndpointInfo remote_endpoints = 9;
  int remote_endpoints_size() const;
  private:
  int _internal_remote_endpoints_size() const;
  public:
  void clear_remote_endpoints();
  ::rocvad::PrEndpointInfo* mutable_remote_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo >*
      mutable_remote_endpoints();
  private:
  const ::rocvad::PrEndpointInfo& _internal_remote_endpoints(int index) const;
  ::rocvad::PrEndpointInfo* _internal_add_remote_endpoints();
  public:
  const ::rocvad::PrEndpointInfo& remote_endpoints(int index) const;
  ::rocvad::PrEndpointInfo* add_remote_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo >&
      remote_endpoints() const;

  // optional string uid = 3;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .rocvad.PrLocalConfig local_config = 5;
  bool has_local_config() const;
  private:
  bool _internal_has_local_config() const;
  public:
  void clear_local_config();
  const ::rocvad::PrLocalConfig& local_config() const;
  PROTOBUF_NODISCARD ::rocvad::PrLocalConfig* release_local_config();
  ::rocvad::PrLocalConfig* mutable_local_config();
  void set_allocated_local_config(::rocvad::PrLocalConfig* local_config);
  private:
  const ::rocvad::PrLocalConfig& _internal_local_config() const;
  ::rocvad::PrLocalConfig* _internal_mutable_local_config();
  public:
  void unsafe_arena_set_allocated_local_config(
      ::rocvad::PrLocalConfig* local_config);
  ::rocvad::PrLocalConfig* unsafe_arena_release_local_config();

  // .rocvad.PrDeviceType type = 1;
  void clear_type();
  ::rocvad::PrDeviceType type() const;
  void set_type(::rocvad::PrDeviceType value);
  private:
  ::rocvad::PrDeviceType _internal_type() const;
  void _internal_set_type(::rocvad::PrDeviceType value);
  public:

  // optional uint32 index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // .rocvad.PrSenderConfig sender_config = 6;
  bool has_sender_config() const;
  private:
  bool _internal_has_sender_config() const;
  public:
  void clear_sender_config();
  const ::rocvad::PrSenderConfig& sender_config() const;
  PROTOBUF_NODISCARD ::rocvad::PrSenderConfig* release_sender_config();
  ::rocvad::PrSenderConfig* mutable_sender_config();
  void set_allocated_sender_config(::rocvad::PrSenderConfig* sender_config);
  private:
  const ::rocvad::PrSenderConfig& _internal_sender_config() const;
  ::rocvad::PrSenderConfig* _internal_mutable_sender_config();
  public:
  void unsafe_arena_set_allocated_sender_config(
      ::rocvad::PrSenderConfig* sender_config);
  ::rocvad::PrSenderConfig* unsafe_arena_release_sender_config();

  // .rocvad.PrReceiverConfig receiver_config = 7;
  bool has_receiver_config() const;
  private:
  bool _internal_has_receiver_config() const;
  public:
  void clear_receiver_config();
  const ::rocvad::PrReceiverConfig& receiver_config() const;
  PROTOBUF_NODISCARD ::rocvad::PrReceiverConfig* release_receiver_config();
  ::rocvad::PrReceiverConfig* mutable_receiver_config();
  void set_allocated_receiver_config(::rocvad::PrReceiverConfig* receiver_config);
  private:
  const ::rocvad::PrReceiverConfig& _internal_receiver_config() const;
  ::rocvad::PrReceiverConfig* _internal_mutable_receiver_config();
  public:
  void unsafe_arena_set_allocated_receiver_config(
      ::rocvad::PrReceiverConfig* receiver_config);
  ::rocvad::PrReceiverConfig* unsafe_arena_release_receiver_config();

  void clear_NetworkConfig();
  NetworkConfigCase NetworkConfig_case() const;
  // @@protoc_insertion_point(class_scope:rocvad.PrDeviceInfo)
 private:
  class _Internal;
  void set_has_sender_config();
  void set_has_receiver_config();

  inline bool has_NetworkConfig() const;
  inline void clear_has_NetworkConfig();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo > local_endpoints_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo > remote_endpoints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::rocvad::PrLocalConfig* local_config_;
    int type_;
    uint32_t index_;
    union NetworkConfigUnion {
      constexpr NetworkConfigUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::rocvad::PrSenderConfig* sender_config_;
      ::rocvad::PrReceiverConfig* receiver_config_;
    } NetworkConfig_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrDeviceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrDeviceList) */ {
 public:
  inline PrDeviceList() : PrDeviceList(nullptr) {}
  ~PrDeviceList() override;
  explicit PROTOBUF_CONSTEXPR PrDeviceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrDeviceList(const PrDeviceList& from);
  PrDeviceList(PrDeviceList&& from) noexcept
    : PrDeviceList() {
    *this = ::std::move(from);
  }

  inline PrDeviceList& operator=(const PrDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrDeviceList& operator=(PrDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrDeviceList* internal_default_instance() {
    return reinterpret_cast<const PrDeviceList*>(
               &_PrDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PrDeviceList& a, PrDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(PrDeviceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrDeviceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrDeviceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrDeviceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrDeviceList& from) {
    PrDeviceList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrDeviceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrDeviceList";
  }
  protected:
  explicit PrDeviceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .rocvad.PrDeviceInfo devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::rocvad::PrDeviceInfo* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrDeviceInfo >*
      mutable_devices();
  private:
  const ::rocvad::PrDeviceInfo& _internal_devices(int index) const;
  ::rocvad::PrDeviceInfo* _internal_add_devices();
  public:
  const ::rocvad::PrDeviceInfo& devices(int index) const;
  ::rocvad::PrDeviceInfo* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrDeviceInfo >&
      devices() const;

  // @@protoc_insertion_point(class_scope:rocvad.PrDeviceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrDeviceInfo > devices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrEndpointRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrEndpointRequest) */ {
 public:
  inline PrEndpointRequest() : PrEndpointRequest(nullptr) {}
  ~PrEndpointRequest() override;
  explicit PROTOBUF_CONSTEXPR PrEndpointRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrEndpointRequest(const PrEndpointRequest& from);
  PrEndpointRequest(PrEndpointRequest&& from) noexcept
    : PrEndpointRequest() {
    *this = ::std::move(from);
  }

  inline PrEndpointRequest& operator=(const PrEndpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrEndpointRequest& operator=(PrEndpointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrEndpointRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrEndpointRequest* internal_default_instance() {
    return reinterpret_cast<const PrEndpointRequest*>(
               &_PrEndpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PrEndpointRequest& a, PrEndpointRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PrEndpointRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrEndpointRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrEndpointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrEndpointRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrEndpointRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrEndpointRequest& from) {
    PrEndpointRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrEndpointRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrEndpointRequest";
  }
  protected:
  explicit PrEndpointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kEndpointFieldNumber = 2,
  };
  // .rocvad.PrDeviceSelector device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::rocvad::PrDeviceSelector& device() const;
  PROTOBUF_NODISCARD ::rocvad::PrDeviceSelector* release_device();
  ::rocvad::PrDeviceSelector* mutable_device();
  void set_allocated_device(::rocvad::PrDeviceSelector* device);
  private:
  const ::rocvad::PrDeviceSelector& _internal_device() const;
  ::rocvad::PrDeviceSelector* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::rocvad::PrDeviceSelector* device);
  ::rocvad::PrDeviceSelector* unsafe_arena_release_device();

  // .rocvad.PrEndpointInfo endpoint = 2;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::rocvad::PrEndpointInfo& endpoint() const;
  PROTOBUF_NODISCARD ::rocvad::PrEndpointInfo* release_endpoint();
  ::rocvad::PrEndpointInfo* mutable_endpoint();
  void set_allocated_endpoint(::rocvad::PrEndpointInfo* endpoint);
  private:
  const ::rocvad::PrEndpointInfo& _internal_endpoint() const;
  ::rocvad::PrEndpointInfo* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::rocvad::PrEndpointInfo* endpoint);
  ::rocvad::PrEndpointInfo* unsafe_arena_release_endpoint();

  // @@protoc_insertion_point(class_scope:rocvad.PrEndpointRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::rocvad::PrDeviceSelector* device_;
    ::rocvad::PrEndpointInfo* endpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrEndpointInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrEndpointInfo) */ {
 public:
  inline PrEndpointInfo() : PrEndpointInfo(nullptr) {}
  ~PrEndpointInfo() override;
  explicit PROTOBUF_CONSTEXPR PrEndpointInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrEndpointInfo(const PrEndpointInfo& from);
  PrEndpointInfo(PrEndpointInfo&& from) noexcept
    : PrEndpointInfo() {
    *this = ::std::move(from);
  }

  inline PrEndpointInfo& operator=(const PrEndpointInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrEndpointInfo& operator=(PrEndpointInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrEndpointInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrEndpointInfo* internal_default_instance() {
    return reinterpret_cast<const PrEndpointInfo*>(
               &_PrEndpointInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PrEndpointInfo& a, PrEndpointInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PrEndpointInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrEndpointInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrEndpointInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrEndpointInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrEndpointInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrEndpointInfo& from) {
    PrEndpointInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrEndpointInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrEndpointInfo";
  }
  protected:
  explicit PrEndpointInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 3,
    kSlotFieldNumber = 1,
    kInterfaceFieldNumber = 2,
  };
  // string uri = 3;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // optional uint32 slot = 1;
  bool has_slot() const;
  private:
  bool _internal_has_slot() const;
  public:
  void clear_slot();
  uint32_t slot() const;
  void set_slot(uint32_t value);
  private:
  uint32_t _internal_slot() const;
  void _internal_set_slot(uint32_t value);
  public:

  // .rocvad.PrInterface interface = 2;
  void clear_interface();
  ::rocvad::PrInterface interface() const;
  void set_interface(::rocvad::PrInterface value);
  private:
  ::rocvad::PrInterface _internal_interface() const;
  void _internal_set_interface(::rocvad::PrInterface value);
  public:

  // @@protoc_insertion_point(class_scope:rocvad.PrEndpointInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    uint32_t slot_;
    int interface_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrLocalConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrLocalConfig) */ {
 public:
  inline PrLocalConfig() : PrLocalConfig(nullptr) {}
  ~PrLocalConfig() override;
  explicit PROTOBUF_CONSTEXPR PrLocalConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrLocalConfig(const PrLocalConfig& from);
  PrLocalConfig(PrLocalConfig&& from) noexcept
    : PrLocalConfig() {
    *this = ::std::move(from);
  }

  inline PrLocalConfig& operator=(const PrLocalConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrLocalConfig& operator=(PrLocalConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrLocalConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrLocalConfig* internal_default_instance() {
    return reinterpret_cast<const PrLocalConfig*>(
               &_PrLocalConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PrLocalConfig& a, PrLocalConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PrLocalConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrLocalConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrLocalConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrLocalConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrLocalConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrLocalConfig& from) {
    PrLocalConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrLocalConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrLocalConfig";
  }
  protected:
  explicit PrLocalConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleRateFieldNumber = 1,
    kChannelLayoutFieldNumber = 2,
  };
  // optional uint32 sample_rate = 1;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // optional .rocvad.PrChannelLayout channel_layout = 2;
  bool has_channel_layout() const;
  private:
  bool _internal_has_channel_layout() const;
  public:
  void clear_channel_layout();
  ::rocvad::PrChannelLayout channel_layout() const;
  void set_channel_layout(::rocvad::PrChannelLayout value);
  private:
  ::rocvad::PrChannelLayout _internal_channel_layout() const;
  void _internal_set_channel_layout(::rocvad::PrChannelLayout value);
  public:

  // @@protoc_insertion_point(class_scope:rocvad.PrLocalConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t sample_rate_;
    int channel_layout_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrSenderConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrSenderConfig) */ {
 public:
  inline PrSenderConfig() : PrSenderConfig(nullptr) {}
  ~PrSenderConfig() override;
  explicit PROTOBUF_CONSTEXPR PrSenderConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrSenderConfig(const PrSenderConfig& from);
  PrSenderConfig(PrSenderConfig&& from) noexcept
    : PrSenderConfig() {
    *this = ::std::move(from);
  }

  inline PrSenderConfig& operator=(const PrSenderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrSenderConfig& operator=(PrSenderConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrSenderConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrSenderConfig* internal_default_instance() {
    return reinterpret_cast<const PrSenderConfig*>(
               &_PrSenderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PrSenderConfig& a, PrSenderConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PrSenderConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrSenderConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrSenderConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrSenderConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrSenderConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrSenderConfig& from) {
    PrSenderConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrSenderConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrSenderConfig";
  }
  protected:
  explicit PrSenderConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketLengthFieldNumber = 2,
    kTargetLatencyFieldNumber = 7,
    kMinLatencyFieldNumber = 8,
    kMaxLatencyFieldNumber = 9,
    kPacketEncodingFieldNumber = 1,
    kPacketInterleavingFieldNumber = 3,
    kFecEncodingFieldNumber = 4,
    kFecBlockSourcePacketsFieldNumber = 5,
    kFecBlockRepairPacketsFieldNumber = 6,
    kLatencyTunerBackendFieldNumber = 10,
    kLatencyTunerProfileFieldNumber = 11,
    kResamplerBackendFieldNumber = 12,
    kResamplerProfileFieldNumber = 13,
  };
  // optional .google.protobuf.Duration packet_length = 2;
  bool has_packet_length() const;
  private:
  bool _internal_has_packet_length() const;
  public:
  void clear_packet_length();
  const ::PROTOBUF_NAMESPACE_ID::Duration& packet_length() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_packet_length();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_packet_length();
  void set_allocated_packet_length(::PROTOBUF_NAMESPACE_ID::Duration* packet_length);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_packet_length() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_packet_length();
  public:
  void unsafe_arena_set_allocated_packet_length(
      ::PROTOBUF_NAMESPACE_ID::Duration* packet_length);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_packet_length();

  // optional .google.protobuf.Duration target_latency = 7;
  bool has_target_latency() const;
  private:
  bool _internal_has_target_latency() const;
  public:
  void clear_target_latency();
  const ::PROTOBUF_NAMESPACE_ID::Duration& target_latency() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_target_latency();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_target_latency();
  void set_allocated_target_latency(::PROTOBUF_NAMESPACE_ID::Duration* target_latency);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_target_latency() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_target_latency();
  public:
  void unsafe_arena_set_allocated_target_latency(
      ::PROTOBUF_NAMESPACE_ID::Duration* target_latency);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_target_latency();

  // optional .google.protobuf.Duration min_latency = 8;
  bool has_min_latency() const;
  private:
  bool _internal_has_min_latency() const;
  public:
  void clear_min_latency();
  const ::PROTOBUF_NAMESPACE_ID::Duration& min_latency() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_min_latency();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_min_latency();
  void set_allocated_min_latency(::PROTOBUF_NAMESPACE_ID::Duration* min_latency);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_min_latency() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_min_latency();
  public:
  void unsafe_arena_set_allocated_min_latency(
      ::PROTOBUF_NAMESPACE_ID::Duration* min_latency);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_min_latency();

  // optional .google.protobuf.Duration max_latency = 9;
  bool has_max_latency() const;
  private:
  bool _internal_has_max_latency() const;
  public:
  void clear_max_latency();
  const ::PROTOBUF_NAMESPACE_ID::Duration& max_latency() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_max_latency();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_max_latency();
  void set_allocated_max_latency(::PROTOBUF_NAMESPACE_ID::Duration* max_latency);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_max_latency() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_max_latency();
  public:
  void unsafe_arena_set_allocated_max_latency(
      ::PROTOBUF_NAMESPACE_ID::Duration* max_latency);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_max_latency();

  // optional .rocvad.PrPacketEncoding packet_encoding = 1;
  bool has_packet_encoding() const;
  private:
  bool _internal_has_packet_encoding() const;
  public:
  void clear_packet_encoding();
  ::rocvad::PrPacketEncoding packet_encoding() const;
  void set_packet_encoding(::rocvad::PrPacketEncoding value);
  private:
  ::rocvad::PrPacketEncoding _internal_packet_encoding() const;
  void _internal_set_packet_encoding(::rocvad::PrPacketEncoding value);
  public:

  // optional bool packet_interleaving = 3;
  bool has_packet_interleaving() const;
  private:
  bool _internal_has_packet_interleaving() const;
  public:
  void clear_packet_interleaving();
  bool packet_interleaving() const;
  void set_packet_interleaving(bool value);
  private:
  bool _internal_packet_interleaving() const;
  void _internal_set_packet_interleaving(bool value);
  public:

  // optional .rocvad.PrFecEncoding fec_encoding = 4;
  bool has_fec_encoding() const;
  private:
  bool _internal_has_fec_encoding() const;
  public:
  void clear_fec_encoding();
  ::rocvad::PrFecEncoding fec_encoding() const;
  void set_fec_encoding(::rocvad::PrFecEncoding value);
  private:
  ::rocvad::PrFecEncoding _internal_fec_encoding() const;
  void _internal_set_fec_encoding(::rocvad::PrFecEncoding value);
  public:

  // optional uint32 fec_block_source_packets = 5;
  bool has_fec_block_source_packets() const;
  private:
  bool _internal_has_fec_block_source_packets() const;
  public:
  void clear_fec_block_source_packets();
  uint32_t fec_block_source_packets() const;
  void set_fec_block_source_packets(uint32_t value);
  private:
  uint32_t _internal_fec_block_source_packets() const;
  void _internal_set_fec_block_source_packets(uint32_t value);
  public:

  // optional uint32 fec_block_repair_packets = 6;
  bool has_fec_block_repair_packets() const;
  private:
  bool _internal_has_fec_block_repair_packets() const;
  public:
  void clear_fec_block_repair_packets();
  uint32_t fec_block_repair_packets() const;
  void set_fec_block_repair_packets(uint32_t value);
  private:
  uint32_t _internal_fec_block_repair_packets() const;
  void _internal_set_fec_block_repair_packets(uint32_t value);
  public:

  // optional .rocvad.PrLatencyTunerBackend latency_tuner_backend = 10;
  bool has_latency_tuner_backend() const;
  private:
  bool _internal_has_latency_tuner_backend() const;
  public:
  void clear_latency_tuner_backend();
  ::rocvad::PrLatencyTunerBackend latency_tuner_backend() const;
  void set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value);
  private:
  ::rocvad::PrLatencyTunerBackend _internal_latency_tuner_backend() const;
  void _internal_set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value);
  public:

  // optional .rocvad.PrLatencyTunerProfile latency_tuner_profile = 11;
  bool has_latency_tuner_profile() const;
  private:
  bool _internal_has_latency_tuner_profile() const;
  public:
  void clear_latency_tuner_profile();
  ::rocvad::PrLatencyTunerProfile latency_tuner_profile() const;
  void set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value);
  private:
  ::rocvad::PrLatencyTunerProfile _internal_latency_tuner_profile() const;
  void _internal_set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value);
  public:

  // optional .rocvad.PrResamplerBackend resampler_backend = 12;
  bool has_resampler_backend() const;
  private:
  bool _internal_has_resampler_backend() const;
  public:
  void clear_resampler_backend();
  ::rocvad::PrResamplerBackend resampler_backend() const;
  void set_resampler_backend(::rocvad::PrResamplerBackend value);
  private:
  ::rocvad::PrResamplerBackend _internal_resampler_backend() const;
  void _internal_set_resampler_backend(::rocvad::PrResamplerBackend value);
  public:

  // optional .rocvad.PrResamplerProfile resampler_profile = 13;
  bool has_resampler_profile() const;
  private:
  bool _internal_has_resampler_profile() const;
  public:
  void clear_resampler_profile();
  ::rocvad::PrResamplerProfile resampler_profile() const;
  void set_resampler_profile(::rocvad::PrResamplerProfile value);
  private:
  ::rocvad::PrResamplerProfile _internal_resampler_profile() const;
  void _internal_set_resampler_profile(::rocvad::PrResamplerProfile value);
  public:

  // @@protoc_insertion_point(class_scope:rocvad.PrSenderConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Duration* packet_length_;
    ::PROTOBUF_NAMESPACE_ID::Duration* target_latency_;
    ::PROTOBUF_NAMESPACE_ID::Duration* min_latency_;
    ::PROTOBUF_NAMESPACE_ID::Duration* max_latency_;
    int packet_encoding_;
    bool packet_interleaving_;
    int fec_encoding_;
    uint32_t fec_block_source_packets_;
    uint32_t fec_block_repair_packets_;
    int latency_tuner_backend_;
    int latency_tuner_profile_;
    int resampler_backend_;
    int resampler_profile_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class PrReceiverConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocvad.PrReceiverConfig) */ {
 public:
  inline PrReceiverConfig() : PrReceiverConfig(nullptr) {}
  ~PrReceiverConfig() override;
  explicit PROTOBUF_CONSTEXPR PrReceiverConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrReceiverConfig(const PrReceiverConfig& from);
  PrReceiverConfig(PrReceiverConfig&& from) noexcept
    : PrReceiverConfig() {
    *this = ::std::move(from);
  }

  inline PrReceiverConfig& operator=(const PrReceiverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrReceiverConfig& operator=(PrReceiverConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrReceiverConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrReceiverConfig* internal_default_instance() {
    return reinterpret_cast<const PrReceiverConfig*>(
               &_PrReceiverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PrReceiverConfig& a, PrReceiverConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PrReceiverConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrReceiverConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrReceiverConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrReceiverConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrReceiverConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrReceiverConfig& from) {
    PrReceiverConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrReceiverConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocvad.PrReceiverConfig";
  }
  protected:
  explicit PrReceiverConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetLatencyFieldNumber = 1,
    kMinLatencyFieldNumber = 2,
    kMaxLatencyFieldNumber = 3,
    kNoPlaybackTimeoutFieldNumber = 8,
    kChoppyPlaybackTimeoutFieldNumber = 9,
    kLatencyTunerBackendFieldNumber = 4,
    kLatencyTunerProfileFieldNumber = 5,
    kResamplerBackendFieldNumber = 6,
    kResamplerProfileFieldNumber = 7,
  };
  // optional .google.protobuf.Duration target_latency = 1;
  bool has_target_latency() const;
  private:
  bool _internal_has_target_latency() const;
  public:
  void clear_target_latency();
  const ::PROTOBUF_NAMESPACE_ID::Duration& target_latency() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_target_latency();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_target_latency();
  void set_allocated_target_latency(::PROTOBUF_NAMESPACE_ID::Duration* target_latency);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_target_latency() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_target_latency();
  public:
  void unsafe_arena_set_allocated_target_latency(
      ::PROTOBUF_NAMESPACE_ID::Duration* target_latency);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_target_latency();

  // optional .google.protobuf.Duration min_latency = 2;
  bool has_min_latency() const;
  private:
  bool _internal_has_min_latency() const;
  public:
  void clear_min_latency();
  const ::PROTOBUF_NAMESPACE_ID::Duration& min_latency() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_min_latency();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_min_latency();
  void set_allocated_min_latency(::PROTOBUF_NAMESPACE_ID::Duration* min_latency);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_min_latency() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_min_latency();
  public:
  void unsafe_arena_set_allocated_min_latency(
      ::PROTOBUF_NAMESPACE_ID::Duration* min_latency);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_min_latency();

  // optional .google.protobuf.Duration max_latency = 3;
  bool has_max_latency() const;
  private:
  bool _internal_has_max_latency() const;
  public:
  void clear_max_latency();
  const ::PROTOBUF_NAMESPACE_ID::Duration& max_latency() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_max_latency();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_max_latency();
  void set_allocated_max_latency(::PROTOBUF_NAMESPACE_ID::Duration* max_latency);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_max_latency() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_max_latency();
  public:
  void unsafe_arena_set_allocated_max_latency(
      ::PROTOBUF_NAMESPACE_ID::Duration* max_latency);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_max_latency();

  // optional .google.protobuf.Duration no_playback_timeout = 8;
  bool has_no_playback_timeout() const;
  private:
  bool _internal_has_no_playback_timeout() const;
  public:
  void clear_no_playback_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& no_playback_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_no_playback_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_no_playback_timeout();
  void set_allocated_no_playback_timeout(::PROTOBUF_NAMESPACE_ID::Duration* no_playback_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_no_playback_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_no_playback_timeout();
  public:
  void unsafe_arena_set_allocated_no_playback_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* no_playback_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_no_playback_timeout();

  // optional .google.protobuf.Duration choppy_playback_timeout = 9;
  bool has_choppy_playback_timeout() const;
  private:
  bool _internal_has_choppy_playback_timeout() const;
  public:
  void clear_choppy_playback_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& choppy_playback_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_choppy_playback_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_choppy_playback_timeout();
  void set_allocated_choppy_playback_timeout(::PROTOBUF_NAMESPACE_ID::Duration* choppy_playback_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_choppy_playback_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_choppy_playback_timeout();
  public:
  void unsafe_arena_set_allocated_choppy_playback_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* choppy_playback_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_choppy_playback_timeout();

  // optional .rocvad.PrLatencyTunerBackend latency_tuner_backend = 4;
  bool has_latency_tuner_backend() const;
  private:
  bool _internal_has_latency_tuner_backend() const;
  public:
  void clear_latency_tuner_backend();
  ::rocvad::PrLatencyTunerBackend latency_tuner_backend() const;
  void set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value);
  private:
  ::rocvad::PrLatencyTunerBackend _internal_latency_tuner_backend() const;
  void _internal_set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value);
  public:

  // optional .rocvad.PrLatencyTunerProfile latency_tuner_profile = 5;
  bool has_latency_tuner_profile() const;
  private:
  bool _internal_has_latency_tuner_profile() const;
  public:
  void clear_latency_tuner_profile();
  ::rocvad::PrLatencyTunerProfile latency_tuner_profile() const;
  void set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value);
  private:
  ::rocvad::PrLatencyTunerProfile _internal_latency_tuner_profile() const;
  void _internal_set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value);
  public:

  // optional .rocvad.PrResamplerBackend resampler_backend = 6;
  bool has_resampler_backend() const;
  private:
  bool _internal_has_resampler_backend() const;
  public:
  void clear_resampler_backend();
  ::rocvad::PrResamplerBackend resampler_backend() const;
  void set_resampler_backend(::rocvad::PrResamplerBackend value);
  private:
  ::rocvad::PrResamplerBackend _internal_resampler_backend() const;
  void _internal_set_resampler_backend(::rocvad::PrResamplerBackend value);
  public:

  // optional .rocvad.PrResamplerProfile resampler_profile = 7;
  bool has_resampler_profile() const;
  private:
  bool _internal_has_resampler_profile() const;
  public:
  void clear_resampler_profile();
  ::rocvad::PrResamplerProfile resampler_profile() const;
  void set_resampler_profile(::rocvad::PrResamplerProfile value);
  private:
  ::rocvad::PrResamplerProfile _internal_resampler_profile() const;
  void _internal_set_resampler_profile(::rocvad::PrResamplerProfile value);
  public:

  // @@protoc_insertion_point(class_scope:rocvad.PrReceiverConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Duration* target_latency_;
    ::PROTOBUF_NAMESPACE_ID::Duration* min_latency_;
    ::PROTOBUF_NAMESPACE_ID::Duration* max_latency_;
    ::PROTOBUF_NAMESPACE_ID::Duration* no_playback_timeout_;
    ::PROTOBUF_NAMESPACE_ID::Duration* choppy_playback_timeout_;
    int latency_tuner_backend_;
    int latency_tuner_profile_;
    int resampler_backend_;
    int resampler_profile_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PrNone

// -------------------------------------------------------------------

// PrDriverInfo

// string version = 1;
inline void PrDriverInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& PrDriverInfo::version() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDriverInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrDriverInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocvad.PrDriverInfo.version)
}
inline std::string* PrDriverInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDriverInfo.version)
  return _s;
}
inline const std::string& PrDriverInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void PrDriverInfo::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* PrDriverInfo::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* PrDriverInfo::release_version() {
  // @@protoc_insertion_point(field_release:rocvad.PrDriverInfo.version)
  return _impl_.version_.Release();
}
inline void PrDriverInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDriverInfo.version)
}

// string commit = 2;
inline void PrDriverInfo::clear_commit() {
  _impl_.commit_.ClearToEmpty();
}
inline const std::string& PrDriverInfo::commit() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDriverInfo.commit)
  return _internal_commit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrDriverInfo::set_commit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.commit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocvad.PrDriverInfo.commit)
}
inline std::string* PrDriverInfo::mutable_commit() {
  std::string* _s = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDriverInfo.commit)
  return _s;
}
inline const std::string& PrDriverInfo::_internal_commit() const {
  return _impl_.commit_.Get();
}
inline void PrDriverInfo::_internal_set_commit(const std::string& value) {
  
  _impl_.commit_.Set(value, GetArenaForAllocation());
}
inline std::string* PrDriverInfo::_internal_mutable_commit() {
  
  return _impl_.commit_.Mutable(GetArenaForAllocation());
}
inline std::string* PrDriverInfo::release_commit() {
  // @@protoc_insertion_point(field_release:rocvad.PrDriverInfo.commit)
  return _impl_.commit_.Release();
}
inline void PrDriverInfo::set_allocated_commit(std::string* commit) {
  if (commit != nullptr) {
    
  } else {
    
  }
  _impl_.commit_.SetAllocated(commit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.commit_.IsDefault()) {
    _impl_.commit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDriverInfo.commit)
}

// -------------------------------------------------------------------

// PrLogEntry

// .google.protobuf.Timestamp time = 1;
inline bool PrLogEntry::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool PrLogEntry::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PrLogEntry::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PrLogEntry::time() const {
  // @@protoc_insertion_point(field_get:rocvad.PrLogEntry.time)
  return _internal_time();
}
inline void PrLogEntry::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrLogEntry.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PrLogEntry::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PrLogEntry::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:rocvad.PrLogEntry.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PrLogEntry::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PrLogEntry::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:rocvad.PrLogEntry.time)
  return _msg;
}
inline void PrLogEntry::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrLogEntry.time)
}

// .rocvad.PrLogEntry.Level level = 2;
inline void PrLogEntry::clear_level() {
  _impl_.level_ = 0;
}
inline ::rocvad::PrLogEntry_Level PrLogEntry::_internal_level() const {
  return static_cast< ::rocvad::PrLogEntry_Level >(_impl_.level_);
}
inline ::rocvad::PrLogEntry_Level PrLogEntry::level() const {
  // @@protoc_insertion_point(field_get:rocvad.PrLogEntry.level)
  return _internal_level();
}
inline void PrLogEntry::_internal_set_level(::rocvad::PrLogEntry_Level value) {
  
  _impl_.level_ = value;
}
inline void PrLogEntry::set_level(::rocvad::PrLogEntry_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:rocvad.PrLogEntry.level)
}

// string text = 3;
inline void PrLogEntry::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& PrLogEntry::text() const {
  // @@protoc_insertion_point(field_get:rocvad.PrLogEntry.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrLogEntry::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocvad.PrLogEntry.text)
}
inline std::string* PrLogEntry::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:rocvad.PrLogEntry.text)
  return _s;
}
inline const std::string& PrLogEntry::_internal_text() const {
  return _impl_.text_.Get();
}
inline void PrLogEntry::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* PrLogEntry::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* PrLogEntry::release_text() {
  // @@protoc_insertion_point(field_release:rocvad.PrLogEntry.text)
  return _impl_.text_.Release();
}
inline void PrLogEntry::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrLogEntry.text)
}

// -------------------------------------------------------------------

// PrDeviceSelector

// uint32 index = 1;
inline bool PrDeviceSelector::_internal_has_index() const {
  return Selector_case() == kIndex;
}
inline bool PrDeviceSelector::has_index() const {
  return _internal_has_index();
}
inline void PrDeviceSelector::set_has_index() {
  _impl_._oneof_case_[0] = kIndex;
}
inline void PrDeviceSelector::clear_index() {
  if (_internal_has_index()) {
    _impl_.Selector_.index_ = 0u;
    clear_has_Selector();
  }
}
inline uint32_t PrDeviceSelector::_internal_index() const {
  if (_internal_has_index()) {
    return _impl_.Selector_.index_;
  }
  return 0u;
}
inline void PrDeviceSelector::_internal_set_index(uint32_t value) {
  if (!_internal_has_index()) {
    clear_Selector();
    set_has_index();
  }
  _impl_.Selector_.index_ = value;
}
inline uint32_t PrDeviceSelector::index() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceSelector.index)
  return _internal_index();
}
inline void PrDeviceSelector::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceSelector.index)
}

// string uid = 2;
inline bool PrDeviceSelector::_internal_has_uid() const {
  return Selector_case() == kUid;
}
inline bool PrDeviceSelector::has_uid() const {
  return _internal_has_uid();
}
inline void PrDeviceSelector::set_has_uid() {
  _impl_._oneof_case_[0] = kUid;
}
inline void PrDeviceSelector::clear_uid() {
  if (_internal_has_uid()) {
    _impl_.Selector_.uid_.Destroy();
    clear_has_Selector();
  }
}
inline const std::string& PrDeviceSelector::uid() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceSelector.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline void PrDeviceSelector::set_uid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_uid()) {
    clear_Selector();
    set_has_uid();
    _impl_.Selector_.uid_.InitDefault();
  }
  _impl_.Selector_.uid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceSelector.uid)
}
inline std::string* PrDeviceSelector::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceSelector.uid)
  return _s;
}
inline const std::string& PrDeviceSelector::_internal_uid() const {
  if (_internal_has_uid()) {
    return _impl_.Selector_.uid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PrDeviceSelector::_internal_set_uid(const std::string& value) {
  if (!_internal_has_uid()) {
    clear_Selector();
    set_has_uid();
    _impl_.Selector_.uid_.InitDefault();
  }
  _impl_.Selector_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* PrDeviceSelector::_internal_mutable_uid() {
  if (!_internal_has_uid()) {
    clear_Selector();
    set_has_uid();
    _impl_.Selector_.uid_.InitDefault();
  }
  return _impl_.Selector_.uid_.Mutable(      GetArenaForAllocation());
}
inline std::string* PrDeviceSelector::release_uid() {
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceSelector.uid)
  if (_internal_has_uid()) {
    clear_has_Selector();
    return _impl_.Selector_.uid_.Release();
  } else {
    return nullptr;
  }
}
inline void PrDeviceSelector::set_allocated_uid(std::string* uid) {
  if (has_Selector()) {
    clear_Selector();
  }
  if (uid != nullptr) {
    set_has_uid();
    _impl_.Selector_.uid_.InitAllocated(uid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDeviceSelector.uid)
}

inline bool PrDeviceSelector::has_Selector() const {
  return Selector_case() != SELECTOR_NOT_SET;
}
inline void PrDeviceSelector::clear_has_Selector() {
  _impl_._oneof_case_[0] = SELECTOR_NOT_SET;
}
inline PrDeviceSelector::SelectorCase PrDeviceSelector::Selector_case() const {
  return PrDeviceSelector::SelectorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PrDeviceInfo

// .rocvad.PrDeviceType type = 1;
inline void PrDeviceInfo::clear_type() {
  _impl_.type_ = 0;
}
inline ::rocvad::PrDeviceType PrDeviceInfo::_internal_type() const {
  return static_cast< ::rocvad::PrDeviceType >(_impl_.type_);
}
inline ::rocvad::PrDeviceType PrDeviceInfo::type() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.type)
  return _internal_type();
}
inline void PrDeviceInfo::_internal_set_type(::rocvad::PrDeviceType value) {
  
  _impl_.type_ = value;
}
inline void PrDeviceInfo::set_type(::rocvad::PrDeviceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceInfo.type)
}

// optional uint32 index = 2;
inline bool PrDeviceInfo::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PrDeviceInfo::has_index() const {
  return _internal_has_index();
}
inline void PrDeviceInfo::clear_index() {
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PrDeviceInfo::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t PrDeviceInfo::index() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.index)
  return _internal_index();
}
inline void PrDeviceInfo::_internal_set_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.index_ = value;
}
inline void PrDeviceInfo::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceInfo.index)
}

// optional string uid = 3;
inline bool PrDeviceInfo::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrDeviceInfo::has_uid() const {
  return _internal_has_uid();
}
inline void PrDeviceInfo::clear_uid() {
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrDeviceInfo::uid() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrDeviceInfo::set_uid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceInfo.uid)
}
inline std::string* PrDeviceInfo::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.uid)
  return _s;
}
inline const std::string& PrDeviceInfo::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void PrDeviceInfo::_internal_set_uid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* PrDeviceInfo::_internal_mutable_uid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* PrDeviceInfo::release_uid() {
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.uid)
  if (!_internal_has_uid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.uid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrDeviceInfo::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDeviceInfo.uid)
}

// optional string name = 4;
inline bool PrDeviceInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrDeviceInfo::has_name() const {
  return _internal_has_name();
}
inline void PrDeviceInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PrDeviceInfo::name() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrDeviceInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocvad.PrDeviceInfo.name)
}
inline std::string* PrDeviceInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.name)
  return _s;
}
inline const std::string& PrDeviceInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PrDeviceInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PrDeviceInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PrDeviceInfo::release_name() {
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrDeviceInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDeviceInfo.name)
}

// .rocvad.PrLocalConfig local_config = 5;
inline bool PrDeviceInfo::_internal_has_local_config() const {
  return this != internal_default_instance() && _impl_.local_config_ != nullptr;
}
inline bool PrDeviceInfo::has_local_config() const {
  return _internal_has_local_config();
}
inline void PrDeviceInfo::clear_local_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_config_ != nullptr) {
    delete _impl_.local_config_;
  }
  _impl_.local_config_ = nullptr;
}
inline const ::rocvad::PrLocalConfig& PrDeviceInfo::_internal_local_config() const {
  const ::rocvad::PrLocalConfig* p = _impl_.local_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocvad::PrLocalConfig&>(
      ::rocvad::_PrLocalConfig_default_instance_);
}
inline const ::rocvad::PrLocalConfig& PrDeviceInfo::local_config() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.local_config)
  return _internal_local_config();
}
inline void PrDeviceInfo::unsafe_arena_set_allocated_local_config(
    ::rocvad::PrLocalConfig* local_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_config_);
  }
  _impl_.local_config_ = local_config;
  if (local_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrDeviceInfo.local_config)
}
inline ::rocvad::PrLocalConfig* PrDeviceInfo::release_local_config() {
  
  ::rocvad::PrLocalConfig* temp = _impl_.local_config_;
  _impl_.local_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocvad::PrLocalConfig* PrDeviceInfo::unsafe_arena_release_local_config() {
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.local_config)
  
  ::rocvad::PrLocalConfig* temp = _impl_.local_config_;
  _impl_.local_config_ = nullptr;
  return temp;
}
inline ::rocvad::PrLocalConfig* PrDeviceInfo::_internal_mutable_local_config() {
  
  if (_impl_.local_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocvad::PrLocalConfig>(GetArenaForAllocation());
    _impl_.local_config_ = p;
  }
  return _impl_.local_config_;
}
inline ::rocvad::PrLocalConfig* PrDeviceInfo::mutable_local_config() {
  ::rocvad::PrLocalConfig* _msg = _internal_mutable_local_config();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.local_config)
  return _msg;
}
inline void PrDeviceInfo::set_allocated_local_config(::rocvad::PrLocalConfig* local_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_config_;
  }
  if (local_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_config);
    if (message_arena != submessage_arena) {
      local_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_config_ = local_config;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrDeviceInfo.local_config)
}

// .rocvad.PrSenderConfig sender_config = 6;
inline bool PrDeviceInfo::_internal_has_sender_config() const {
  return NetworkConfig_case() == kSenderConfig;
}
inline bool PrDeviceInfo::has_sender_config() const {
  return _internal_has_sender_config();
}
inline void PrDeviceInfo::set_has_sender_config() {
  _impl_._oneof_case_[0] = kSenderConfig;
}
inline void PrDeviceInfo::clear_sender_config() {
  if (_internal_has_sender_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.NetworkConfig_.sender_config_;
    }
    clear_has_NetworkConfig();
  }
}
inline ::rocvad::PrSenderConfig* PrDeviceInfo::release_sender_config() {
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.sender_config)
  if (_internal_has_sender_config()) {
    clear_has_NetworkConfig();
    ::rocvad::PrSenderConfig* temp = _impl_.NetworkConfig_.sender_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.NetworkConfig_.sender_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocvad::PrSenderConfig& PrDeviceInfo::_internal_sender_config() const {
  return _internal_has_sender_config()
      ? *_impl_.NetworkConfig_.sender_config_
      : reinterpret_cast< ::rocvad::PrSenderConfig&>(::rocvad::_PrSenderConfig_default_instance_);
}
inline const ::rocvad::PrSenderConfig& PrDeviceInfo::sender_config() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.sender_config)
  return _internal_sender_config();
}
inline ::rocvad::PrSenderConfig* PrDeviceInfo::unsafe_arena_release_sender_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocvad.PrDeviceInfo.sender_config)
  if (_internal_has_sender_config()) {
    clear_has_NetworkConfig();
    ::rocvad::PrSenderConfig* temp = _impl_.NetworkConfig_.sender_config_;
    _impl_.NetworkConfig_.sender_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PrDeviceInfo::unsafe_arena_set_allocated_sender_config(::rocvad::PrSenderConfig* sender_config) {
  clear_NetworkConfig();
  if (sender_config) {
    set_has_sender_config();
    _impl_.NetworkConfig_.sender_config_ = sender_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrDeviceInfo.sender_config)
}
inline ::rocvad::PrSenderConfig* PrDeviceInfo::_internal_mutable_sender_config() {
  if (!_internal_has_sender_config()) {
    clear_NetworkConfig();
    set_has_sender_config();
    _impl_.NetworkConfig_.sender_config_ = CreateMaybeMessage< ::rocvad::PrSenderConfig >(GetArenaForAllocation());
  }
  return _impl_.NetworkConfig_.sender_config_;
}
inline ::rocvad::PrSenderConfig* PrDeviceInfo::mutable_sender_config() {
  ::rocvad::PrSenderConfig* _msg = _internal_mutable_sender_config();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.sender_config)
  return _msg;
}

// .rocvad.PrReceiverConfig receiver_config = 7;
inline bool PrDeviceInfo::_internal_has_receiver_config() const {
  return NetworkConfig_case() == kReceiverConfig;
}
inline bool PrDeviceInfo::has_receiver_config() const {
  return _internal_has_receiver_config();
}
inline void PrDeviceInfo::set_has_receiver_config() {
  _impl_._oneof_case_[0] = kReceiverConfig;
}
inline void PrDeviceInfo::clear_receiver_config() {
  if (_internal_has_receiver_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.NetworkConfig_.receiver_config_;
    }
    clear_has_NetworkConfig();
  }
}
inline ::rocvad::PrReceiverConfig* PrDeviceInfo::release_receiver_config() {
  // @@protoc_insertion_point(field_release:rocvad.PrDeviceInfo.receiver_config)
  if (_internal_has_receiver_config()) {
    clear_has_NetworkConfig();
    ::rocvad::PrReceiverConfig* temp = _impl_.NetworkConfig_.receiver_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.NetworkConfig_.receiver_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocvad::PrReceiverConfig& PrDeviceInfo::_internal_receiver_config() const {
  return _internal_has_receiver_config()
      ? *_impl_.NetworkConfig_.receiver_config_
      : reinterpret_cast< ::rocvad::PrReceiverConfig&>(::rocvad::_PrReceiverConfig_default_instance_);
}
inline const ::rocvad::PrReceiverConfig& PrDeviceInfo::receiver_config() const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.receiver_config)
  return _internal_receiver_config();
}
inline ::rocvad::PrReceiverConfig* PrDeviceInfo::unsafe_arena_release_receiver_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocvad.PrDeviceInfo.receiver_config)
  if (_internal_has_receiver_config()) {
    clear_has_NetworkConfig();
    ::rocvad::PrReceiverConfig* temp = _impl_.NetworkConfig_.receiver_config_;
    _impl_.NetworkConfig_.receiver_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PrDeviceInfo::unsafe_arena_set_allocated_receiver_config(::rocvad::PrReceiverConfig* receiver_config) {
  clear_NetworkConfig();
  if (receiver_config) {
    set_has_receiver_config();
    _impl_.NetworkConfig_.receiver_config_ = receiver_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrDeviceInfo.receiver_config)
}
inline ::rocvad::PrReceiverConfig* PrDeviceInfo::_internal_mutable_receiver_config() {
  if (!_internal_has_receiver_config()) {
    clear_NetworkConfig();
    set_has_receiver_config();
    _impl_.NetworkConfig_.receiver_config_ = CreateMaybeMessage< ::rocvad::PrReceiverConfig >(GetArenaForAllocation());
  }
  return _impl_.NetworkConfig_.receiver_config_;
}
inline ::rocvad::PrReceiverConfig* PrDeviceInfo::mutable_receiver_config() {
  ::rocvad::PrReceiverConfig* _msg = _internal_mutable_receiver_config();
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.receiver_config)
  return _msg;
}

// repeated .rocvad.PrEndpointInfo local_endpoints = 8;
inline int PrDeviceInfo::_internal_local_endpoints_size() const {
  return _impl_.local_endpoints_.size();
}
inline int PrDeviceInfo::local_endpoints_size() const {
  return _internal_local_endpoints_size();
}
inline void PrDeviceInfo::clear_local_endpoints() {
  _impl_.local_endpoints_.Clear();
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::mutable_local_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.local_endpoints)
  return _impl_.local_endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo >*
PrDeviceInfo::mutable_local_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:rocvad.PrDeviceInfo.local_endpoints)
  return &_impl_.local_endpoints_;
}
inline const ::rocvad::PrEndpointInfo& PrDeviceInfo::_internal_local_endpoints(int index) const {
  return _impl_.local_endpoints_.Get(index);
}
inline const ::rocvad::PrEndpointInfo& PrDeviceInfo::local_endpoints(int index) const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.local_endpoints)
  return _internal_local_endpoints(index);
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::_internal_add_local_endpoints() {
  return _impl_.local_endpoints_.Add();
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::add_local_endpoints() {
  ::rocvad::PrEndpointInfo* _add = _internal_add_local_endpoints();
  // @@protoc_insertion_point(field_add:rocvad.PrDeviceInfo.local_endpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo >&
PrDeviceInfo::local_endpoints() const {
  // @@protoc_insertion_point(field_list:rocvad.PrDeviceInfo.local_endpoints)
  return _impl_.local_endpoints_;
}

// repeated .rocvad.PrEndpointInfo remote_endpoints = 9;
inline int PrDeviceInfo::_internal_remote_endpoints_size() const {
  return _impl_.remote_endpoints_.size();
}
inline int PrDeviceInfo::remote_endpoints_size() const {
  return _internal_remote_endpoints_size();
}
inline void PrDeviceInfo::clear_remote_endpoints() {
  _impl_.remote_endpoints_.Clear();
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::mutable_remote_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceInfo.remote_endpoints)
  return _impl_.remote_endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo >*
PrDeviceInfo::mutable_remote_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:rocvad.PrDeviceInfo.remote_endpoints)
  return &_impl_.remote_endpoints_;
}
inline const ::rocvad::PrEndpointInfo& PrDeviceInfo::_internal_remote_endpoints(int index) const {
  return _impl_.remote_endpoints_.Get(index);
}
inline const ::rocvad::PrEndpointInfo& PrDeviceInfo::remote_endpoints(int index) const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceInfo.remote_endpoints)
  return _internal_remote_endpoints(index);
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::_internal_add_remote_endpoints() {
  return _impl_.remote_endpoints_.Add();
}
inline ::rocvad::PrEndpointInfo* PrDeviceInfo::add_remote_endpoints() {
  ::rocvad::PrEndpointInfo* _add = _internal_add_remote_endpoints();
  // @@protoc_insertion_point(field_add:rocvad.PrDeviceInfo.remote_endpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrEndpointInfo >&
PrDeviceInfo::remote_endpoints() const {
  // @@protoc_insertion_point(field_list:rocvad.PrDeviceInfo.remote_endpoints)
  return _impl_.remote_endpoints_;
}

inline bool PrDeviceInfo::has_NetworkConfig() const {
  return NetworkConfig_case() != NETWORKCONFIG_NOT_SET;
}
inline void PrDeviceInfo::clear_has_NetworkConfig() {
  _impl_._oneof_case_[0] = NETWORKCONFIG_NOT_SET;
}
inline PrDeviceInfo::NetworkConfigCase PrDeviceInfo::NetworkConfig_case() const {
  return PrDeviceInfo::NetworkConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PrDeviceList

// repeated .rocvad.PrDeviceInfo devices = 1;
inline int PrDeviceList::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int PrDeviceList::devices_size() const {
  return _internal_devices_size();
}
inline void PrDeviceList::clear_devices() {
  _impl_.devices_.Clear();
}
inline ::rocvad::PrDeviceInfo* PrDeviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:rocvad.PrDeviceList.devices)
  return _impl_.devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrDeviceInfo >*
PrDeviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:rocvad.PrDeviceList.devices)
  return &_impl_.devices_;
}
inline const ::rocvad::PrDeviceInfo& PrDeviceList::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const ::rocvad::PrDeviceInfo& PrDeviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:rocvad.PrDeviceList.devices)
  return _internal_devices(index);
}
inline ::rocvad::PrDeviceInfo* PrDeviceList::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline ::rocvad::PrDeviceInfo* PrDeviceList::add_devices() {
  ::rocvad::PrDeviceInfo* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:rocvad.PrDeviceList.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocvad::PrDeviceInfo >&
PrDeviceList::devices() const {
  // @@protoc_insertion_point(field_list:rocvad.PrDeviceList.devices)
  return _impl_.devices_;
}

// -------------------------------------------------------------------

// PrEndpointRequest

// .rocvad.PrDeviceSelector device = 1;
inline bool PrEndpointRequest::_internal_has_device() const {
  return this != internal_default_instance() && _impl_.device_ != nullptr;
}
inline bool PrEndpointRequest::has_device() const {
  return _internal_has_device();
}
inline void PrEndpointRequest::clear_device() {
  if (GetArenaForAllocation() == nullptr && _impl_.device_ != nullptr) {
    delete _impl_.device_;
  }
  _impl_.device_ = nullptr;
}
inline const ::rocvad::PrDeviceSelector& PrEndpointRequest::_internal_device() const {
  const ::rocvad::PrDeviceSelector* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocvad::PrDeviceSelector&>(
      ::rocvad::_PrDeviceSelector_default_instance_);
}
inline const ::rocvad::PrDeviceSelector& PrEndpointRequest::device() const {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointRequest.device)
  return _internal_device();
}
inline void PrEndpointRequest::unsafe_arena_set_allocated_device(
    ::rocvad::PrDeviceSelector* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrEndpointRequest.device)
}
inline ::rocvad::PrDeviceSelector* PrEndpointRequest::release_device() {
  
  ::rocvad::PrDeviceSelector* temp = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocvad::PrDeviceSelector* PrEndpointRequest::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:rocvad.PrEndpointRequest.device)
  
  ::rocvad::PrDeviceSelector* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::rocvad::PrDeviceSelector* PrEndpointRequest::_internal_mutable_device() {
  
  if (_impl_.device_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocvad::PrDeviceSelector>(GetArenaForAllocation());
    _impl_.device_ = p;
  }
  return _impl_.device_;
}
inline ::rocvad::PrDeviceSelector* PrEndpointRequest::mutable_device() {
  ::rocvad::PrDeviceSelector* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:rocvad.PrEndpointRequest.device)
  return _msg;
}
inline void PrEndpointRequest::set_allocated_device(::rocvad::PrDeviceSelector* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_ = device;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrEndpointRequest.device)
}

// .rocvad.PrEndpointInfo endpoint = 2;
inline bool PrEndpointRequest::_internal_has_endpoint() const {
  return this != internal_default_instance() && _impl_.endpoint_ != nullptr;
}
inline bool PrEndpointRequest::has_endpoint() const {
  return _internal_has_endpoint();
}
inline void PrEndpointRequest::clear_endpoint() {
  if (GetArenaForAllocation() == nullptr && _impl_.endpoint_ != nullptr) {
    delete _impl_.endpoint_;
  }
  _impl_.endpoint_ = nullptr;
}
inline const ::rocvad::PrEndpointInfo& PrEndpointRequest::_internal_endpoint() const {
  const ::rocvad::PrEndpointInfo* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocvad::PrEndpointInfo&>(
      ::rocvad::_PrEndpointInfo_default_instance_);
}
inline const ::rocvad::PrEndpointInfo& PrEndpointRequest::endpoint() const {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointRequest.endpoint)
  return _internal_endpoint();
}
inline void PrEndpointRequest::unsafe_arena_set_allocated_endpoint(
    ::rocvad::PrEndpointInfo* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrEndpointRequest.endpoint)
}
inline ::rocvad::PrEndpointInfo* PrEndpointRequest::release_endpoint() {
  
  ::rocvad::PrEndpointInfo* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocvad::PrEndpointInfo* PrEndpointRequest::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:rocvad.PrEndpointRequest.endpoint)
  
  ::rocvad::PrEndpointInfo* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::rocvad::PrEndpointInfo* PrEndpointRequest::_internal_mutable_endpoint() {
  
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocvad::PrEndpointInfo>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::rocvad::PrEndpointInfo* PrEndpointRequest::mutable_endpoint() {
  ::rocvad::PrEndpointInfo* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:rocvad.PrEndpointRequest.endpoint)
  return _msg;
}
inline void PrEndpointRequest::set_allocated_endpoint(::rocvad::PrEndpointInfo* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.endpoint_;
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(endpoint);
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrEndpointRequest.endpoint)
}

// -------------------------------------------------------------------

// PrEndpointInfo

// optional uint32 slot = 1;
inline bool PrEndpointInfo::_internal_has_slot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrEndpointInfo::has_slot() const {
  return _internal_has_slot();
}
inline void PrEndpointInfo::clear_slot() {
  _impl_.slot_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PrEndpointInfo::_internal_slot() const {
  return _impl_.slot_;
}
inline uint32_t PrEndpointInfo::slot() const {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointInfo.slot)
  return _internal_slot();
}
inline void PrEndpointInfo::_internal_set_slot(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.slot_ = value;
}
inline void PrEndpointInfo::set_slot(uint32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:rocvad.PrEndpointInfo.slot)
}

// .rocvad.PrInterface interface = 2;
inline void PrEndpointInfo::clear_interface() {
  _impl_.interface_ = 0;
}
inline ::rocvad::PrInterface PrEndpointInfo::_internal_interface() const {
  return static_cast< ::rocvad::PrInterface >(_impl_.interface_);
}
inline ::rocvad::PrInterface PrEndpointInfo::interface() const {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointInfo.interface)
  return _internal_interface();
}
inline void PrEndpointInfo::_internal_set_interface(::rocvad::PrInterface value) {
  
  _impl_.interface_ = value;
}
inline void PrEndpointInfo::set_interface(::rocvad::PrInterface value) {
  _internal_set_interface(value);
  // @@protoc_insertion_point(field_set:rocvad.PrEndpointInfo.interface)
}

// string uri = 3;
inline void PrEndpointInfo::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& PrEndpointInfo::uri() const {
  // @@protoc_insertion_point(field_get:rocvad.PrEndpointInfo.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrEndpointInfo::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocvad.PrEndpointInfo.uri)
}
inline std::string* PrEndpointInfo::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:rocvad.PrEndpointInfo.uri)
  return _s;
}
inline const std::string& PrEndpointInfo::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void PrEndpointInfo::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* PrEndpointInfo::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* PrEndpointInfo::release_uri() {
  // @@protoc_insertion_point(field_release:rocvad.PrEndpointInfo.uri)
  return _impl_.uri_.Release();
}
inline void PrEndpointInfo::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrEndpointInfo.uri)
}

// -------------------------------------------------------------------

// PrLocalConfig

// optional uint32 sample_rate = 1;
inline bool PrLocalConfig::_internal_has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrLocalConfig::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void PrLocalConfig::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PrLocalConfig::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t PrLocalConfig::sample_rate() const {
  // @@protoc_insertion_point(field_get:rocvad.PrLocalConfig.sample_rate)
  return _internal_sample_rate();
}
inline void PrLocalConfig::_internal_set_sample_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sample_rate_ = value;
}
inline void PrLocalConfig::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:rocvad.PrLocalConfig.sample_rate)
}

// optional .rocvad.PrChannelLayout channel_layout = 2;
inline bool PrLocalConfig::_internal_has_channel_layout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrLocalConfig::has_channel_layout() const {
  return _internal_has_channel_layout();
}
inline void PrLocalConfig::clear_channel_layout() {
  _impl_.channel_layout_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::rocvad::PrChannelLayout PrLocalConfig::_internal_channel_layout() const {
  return static_cast< ::rocvad::PrChannelLayout >(_impl_.channel_layout_);
}
inline ::rocvad::PrChannelLayout PrLocalConfig::channel_layout() const {
  // @@protoc_insertion_point(field_get:rocvad.PrLocalConfig.channel_layout)
  return _internal_channel_layout();
}
inline void PrLocalConfig::_internal_set_channel_layout(::rocvad::PrChannelLayout value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_layout_ = value;
}
inline void PrLocalConfig::set_channel_layout(::rocvad::PrChannelLayout value) {
  _internal_set_channel_layout(value);
  // @@protoc_insertion_point(field_set:rocvad.PrLocalConfig.channel_layout)
}

// -------------------------------------------------------------------

// PrSenderConfig

// optional .rocvad.PrPacketEncoding packet_encoding = 1;
inline bool PrSenderConfig::_internal_has_packet_encoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PrSenderConfig::has_packet_encoding() const {
  return _internal_has_packet_encoding();
}
inline void PrSenderConfig::clear_packet_encoding() {
  _impl_.packet_encoding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::rocvad::PrPacketEncoding PrSenderConfig::_internal_packet_encoding() const {
  return static_cast< ::rocvad::PrPacketEncoding >(_impl_.packet_encoding_);
}
inline ::rocvad::PrPacketEncoding PrSenderConfig::packet_encoding() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.packet_encoding)
  return _internal_packet_encoding();
}
inline void PrSenderConfig::_internal_set_packet_encoding(::rocvad::PrPacketEncoding value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.packet_encoding_ = value;
}
inline void PrSenderConfig::set_packet_encoding(::rocvad::PrPacketEncoding value) {
  _internal_set_packet_encoding(value);
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.packet_encoding)
}

// optional .google.protobuf.Duration packet_length = 2;
inline bool PrSenderConfig::_internal_has_packet_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_length_ != nullptr);
  return value;
}
inline bool PrSenderConfig::has_packet_length() const {
  return _internal_has_packet_length();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrSenderConfig::_internal_packet_length() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.packet_length_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrSenderConfig::packet_length() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.packet_length)
  return _internal_packet_length();
}
inline void PrSenderConfig::unsafe_arena_set_allocated_packet_length(
    ::PROTOBUF_NAMESPACE_ID::Duration* packet_length) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_length_);
  }
  _impl_.packet_length_ = packet_length;
  if (packet_length) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrSenderConfig.packet_length)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::release_packet_length() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.packet_length_;
  _impl_.packet_length_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::unsafe_arena_release_packet_length() {
  // @@protoc_insertion_point(field_release:rocvad.PrSenderConfig.packet_length)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.packet_length_;
  _impl_.packet_length_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::_internal_mutable_packet_length() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.packet_length_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.packet_length_ = p;
  }
  return _impl_.packet_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::mutable_packet_length() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_packet_length();
  // @@protoc_insertion_point(field_mutable:rocvad.PrSenderConfig.packet_length)
  return _msg;
}
inline void PrSenderConfig::set_allocated_packet_length(::PROTOBUF_NAMESPACE_ID::Duration* packet_length) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_length_);
  }
  if (packet_length) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet_length));
    if (message_arena != submessage_arena) {
      packet_length = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_length, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.packet_length_ = packet_length;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrSenderConfig.packet_length)
}

// optional bool packet_interleaving = 3;
inline bool PrSenderConfig::_internal_has_packet_interleaving() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PrSenderConfig::has_packet_interleaving() const {
  return _internal_has_packet_interleaving();
}
inline void PrSenderConfig::clear_packet_interleaving() {
  _impl_.packet_interleaving_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool PrSenderConfig::_internal_packet_interleaving() const {
  return _impl_.packet_interleaving_;
}
inline bool PrSenderConfig::packet_interleaving() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.packet_interleaving)
  return _internal_packet_interleaving();
}
inline void PrSenderConfig::_internal_set_packet_interleaving(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.packet_interleaving_ = value;
}
inline void PrSenderConfig::set_packet_interleaving(bool value) {
  _internal_set_packet_interleaving(value);
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.packet_interleaving)
}

// optional .rocvad.PrFecEncoding fec_encoding = 4;
inline bool PrSenderConfig::_internal_has_fec_encoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PrSenderConfig::has_fec_encoding() const {
  return _internal_has_fec_encoding();
}
inline void PrSenderConfig::clear_fec_encoding() {
  _impl_.fec_encoding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::rocvad::PrFecEncoding PrSenderConfig::_internal_fec_encoding() const {
  return static_cast< ::rocvad::PrFecEncoding >(_impl_.fec_encoding_);
}
inline ::rocvad::PrFecEncoding PrSenderConfig::fec_encoding() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.fec_encoding)
  return _internal_fec_encoding();
}
inline void PrSenderConfig::_internal_set_fec_encoding(::rocvad::PrFecEncoding value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.fec_encoding_ = value;
}
inline void PrSenderConfig::set_fec_encoding(::rocvad::PrFecEncoding value) {
  _internal_set_fec_encoding(value);
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.fec_encoding)
}

// optional uint32 fec_block_source_packets = 5;
inline bool PrSenderConfig::_internal_has_fec_block_source_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PrSenderConfig::has_fec_block_source_packets() const {
  return _internal_has_fec_block_source_packets();
}
inline void PrSenderConfig::clear_fec_block_source_packets() {
  _impl_.fec_block_source_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t PrSenderConfig::_internal_fec_block_source_packets() const {
  return _impl_.fec_block_source_packets_;
}
inline uint32_t PrSenderConfig::fec_block_source_packets() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.fec_block_source_packets)
  return _internal_fec_block_source_packets();
}
inline void PrSenderConfig::_internal_set_fec_block_source_packets(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.fec_block_source_packets_ = value;
}
inline void PrSenderConfig::set_fec_block_source_packets(uint32_t value) {
  _internal_set_fec_block_source_packets(value);
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.fec_block_source_packets)
}

// optional uint32 fec_block_repair_packets = 6;
inline bool PrSenderConfig::_internal_has_fec_block_repair_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PrSenderConfig::has_fec_block_repair_packets() const {
  return _internal_has_fec_block_repair_packets();
}
inline void PrSenderConfig::clear_fec_block_repair_packets() {
  _impl_.fec_block_repair_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t PrSenderConfig::_internal_fec_block_repair_packets() const {
  return _impl_.fec_block_repair_packets_;
}
inline uint32_t PrSenderConfig::fec_block_repair_packets() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.fec_block_repair_packets)
  return _internal_fec_block_repair_packets();
}
inline void PrSenderConfig::_internal_set_fec_block_repair_packets(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.fec_block_repair_packets_ = value;
}
inline void PrSenderConfig::set_fec_block_repair_packets(uint32_t value) {
  _internal_set_fec_block_repair_packets(value);
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.fec_block_repair_packets)
}

// optional .google.protobuf.Duration target_latency = 7;
inline bool PrSenderConfig::_internal_has_target_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_latency_ != nullptr);
  return value;
}
inline bool PrSenderConfig::has_target_latency() const {
  return _internal_has_target_latency();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrSenderConfig::_internal_target_latency() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.target_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrSenderConfig::target_latency() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.target_latency)
  return _internal_target_latency();
}
inline void PrSenderConfig::unsafe_arena_set_allocated_target_latency(
    ::PROTOBUF_NAMESPACE_ID::Duration* target_latency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_latency_);
  }
  _impl_.target_latency_ = target_latency;
  if (target_latency) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrSenderConfig.target_latency)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::release_target_latency() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::unsafe_arena_release_target_latency() {
  // @@protoc_insertion_point(field_release:rocvad.PrSenderConfig.target_latency)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::_internal_mutable_target_latency() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.target_latency_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.target_latency_ = p;
  }
  return _impl_.target_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::mutable_target_latency() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_target_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrSenderConfig.target_latency)
  return _msg;
}
inline void PrSenderConfig::set_allocated_target_latency(::PROTOBUF_NAMESPACE_ID::Duration* target_latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_latency_);
  }
  if (target_latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_latency));
    if (message_arena != submessage_arena) {
      target_latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_latency, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.target_latency_ = target_latency;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrSenderConfig.target_latency)
}

// optional .google.protobuf.Duration min_latency = 8;
inline bool PrSenderConfig::_internal_has_min_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_latency_ != nullptr);
  return value;
}
inline bool PrSenderConfig::has_min_latency() const {
  return _internal_has_min_latency();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrSenderConfig::_internal_min_latency() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.min_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrSenderConfig::min_latency() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.min_latency)
  return _internal_min_latency();
}
inline void PrSenderConfig::unsafe_arena_set_allocated_min_latency(
    ::PROTOBUF_NAMESPACE_ID::Duration* min_latency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_latency_);
  }
  _impl_.min_latency_ = min_latency;
  if (min_latency) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrSenderConfig.min_latency)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::release_min_latency() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.min_latency_;
  _impl_.min_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::unsafe_arena_release_min_latency() {
  // @@protoc_insertion_point(field_release:rocvad.PrSenderConfig.min_latency)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.min_latency_;
  _impl_.min_latency_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::_internal_mutable_min_latency() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.min_latency_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.min_latency_ = p;
  }
  return _impl_.min_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::mutable_min_latency() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_min_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrSenderConfig.min_latency)
  return _msg;
}
inline void PrSenderConfig::set_allocated_min_latency(::PROTOBUF_NAMESPACE_ID::Duration* min_latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_latency_);
  }
  if (min_latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_latency));
    if (message_arena != submessage_arena) {
      min_latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_latency, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.min_latency_ = min_latency;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrSenderConfig.min_latency)
}

// optional .google.protobuf.Duration max_latency = 9;
inline bool PrSenderConfig::_internal_has_max_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_latency_ != nullptr);
  return value;
}
inline bool PrSenderConfig::has_max_latency() const {
  return _internal_has_max_latency();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrSenderConfig::_internal_max_latency() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.max_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrSenderConfig::max_latency() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.max_latency)
  return _internal_max_latency();
}
inline void PrSenderConfig::unsafe_arena_set_allocated_max_latency(
    ::PROTOBUF_NAMESPACE_ID::Duration* max_latency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_latency_);
  }
  _impl_.max_latency_ = max_latency;
  if (max_latency) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrSenderConfig.max_latency)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::release_max_latency() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.max_latency_;
  _impl_.max_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::unsafe_arena_release_max_latency() {
  // @@protoc_insertion_point(field_release:rocvad.PrSenderConfig.max_latency)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.max_latency_;
  _impl_.max_latency_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::_internal_mutable_max_latency() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.max_latency_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.max_latency_ = p;
  }
  return _impl_.max_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrSenderConfig::mutable_max_latency() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_max_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrSenderConfig.max_latency)
  return _msg;
}
inline void PrSenderConfig::set_allocated_max_latency(::PROTOBUF_NAMESPACE_ID::Duration* max_latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_latency_);
  }
  if (max_latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_latency));
    if (message_arena != submessage_arena) {
      max_latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_latency, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.max_latency_ = max_latency;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrSenderConfig.max_latency)
}

// optional .rocvad.PrLatencyTunerBackend latency_tuner_backend = 10;
inline bool PrSenderConfig::_internal_has_latency_tuner_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PrSenderConfig::has_latency_tuner_backend() const {
  return _internal_has_latency_tuner_backend();
}
inline void PrSenderConfig::clear_latency_tuner_backend() {
  _impl_.latency_tuner_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::rocvad::PrLatencyTunerBackend PrSenderConfig::_internal_latency_tuner_backend() const {
  return static_cast< ::rocvad::PrLatencyTunerBackend >(_impl_.latency_tuner_backend_);
}
inline ::rocvad::PrLatencyTunerBackend PrSenderConfig::latency_tuner_backend() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.latency_tuner_backend)
  return _internal_latency_tuner_backend();
}
inline void PrSenderConfig::_internal_set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.latency_tuner_backend_ = value;
}
inline void PrSenderConfig::set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value) {
  _internal_set_latency_tuner_backend(value);
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.latency_tuner_backend)
}

// optional .rocvad.PrLatencyTunerProfile latency_tuner_profile = 11;
inline bool PrSenderConfig::_internal_has_latency_tuner_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PrSenderConfig::has_latency_tuner_profile() const {
  return _internal_has_latency_tuner_profile();
}
inline void PrSenderConfig::clear_latency_tuner_profile() {
  _impl_.latency_tuner_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::rocvad::PrLatencyTunerProfile PrSenderConfig::_internal_latency_tuner_profile() const {
  return static_cast< ::rocvad::PrLatencyTunerProfile >(_impl_.latency_tuner_profile_);
}
inline ::rocvad::PrLatencyTunerProfile PrSenderConfig::latency_tuner_profile() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.latency_tuner_profile)
  return _internal_latency_tuner_profile();
}
inline void PrSenderConfig::_internal_set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.latency_tuner_profile_ = value;
}
inline void PrSenderConfig::set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value) {
  _internal_set_latency_tuner_profile(value);
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.latency_tuner_profile)
}

// optional .rocvad.PrResamplerBackend resampler_backend = 12;
inline bool PrSenderConfig::_internal_has_resampler_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool PrSenderConfig::has_resampler_backend() const {
  return _internal_has_resampler_backend();
}
inline void PrSenderConfig::clear_resampler_backend() {
  _impl_.resampler_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::rocvad::PrResamplerBackend PrSenderConfig::_internal_resampler_backend() const {
  return static_cast< ::rocvad::PrResamplerBackend >(_impl_.resampler_backend_);
}
inline ::rocvad::PrResamplerBackend PrSenderConfig::resampler_backend() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.resampler_backend)
  return _internal_resampler_backend();
}
inline void PrSenderConfig::_internal_set_resampler_backend(::rocvad::PrResamplerBackend value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.resampler_backend_ = value;
}
inline void PrSenderConfig::set_resampler_backend(::rocvad::PrResamplerBackend value) {
  _internal_set_resampler_backend(value);
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.resampler_backend)
}

// optional .rocvad.PrResamplerProfile resampler_profile = 13;
inline bool PrSenderConfig::_internal_has_resampler_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool PrSenderConfig::has_resampler_profile() const {
  return _internal_has_resampler_profile();
}
inline void PrSenderConfig::clear_resampler_profile() {
  _impl_.resampler_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::rocvad::PrResamplerProfile PrSenderConfig::_internal_resampler_profile() const {
  return static_cast< ::rocvad::PrResamplerProfile >(_impl_.resampler_profile_);
}
inline ::rocvad::PrResamplerProfile PrSenderConfig::resampler_profile() const {
  // @@protoc_insertion_point(field_get:rocvad.PrSenderConfig.resampler_profile)
  return _internal_resampler_profile();
}
inline void PrSenderConfig::_internal_set_resampler_profile(::rocvad::PrResamplerProfile value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.resampler_profile_ = value;
}
inline void PrSenderConfig::set_resampler_profile(::rocvad::PrResamplerProfile value) {
  _internal_set_resampler_profile(value);
  // @@protoc_insertion_point(field_set:rocvad.PrSenderConfig.resampler_profile)
}

// -------------------------------------------------------------------

// PrReceiverConfig

// optional .google.protobuf.Duration target_latency = 1;
inline bool PrReceiverConfig::_internal_has_target_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_latency_ != nullptr);
  return value;
}
inline bool PrReceiverConfig::has_target_latency() const {
  return _internal_has_target_latency();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::_internal_target_latency() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.target_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::target_latency() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.target_latency)
  return _internal_target_latency();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_target_latency(
    ::PROTOBUF_NAMESPACE_ID::Duration* target_latency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_latency_);
  }
  _impl_.target_latency_ = target_latency;
  if (target_latency) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.target_latency)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::release_target_latency() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::unsafe_arena_release_target_latency() {
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.target_latency)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::_internal_mutable_target_latency() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_latency_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.target_latency_ = p;
  }
  return _impl_.target_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::mutable_target_latency() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_target_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.target_latency)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_target_latency(::PROTOBUF_NAMESPACE_ID::Duration* target_latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_latency_);
  }
  if (target_latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_latency));
    if (message_arena != submessage_arena) {
      target_latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_latency, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_latency_ = target_latency;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.target_latency)
}

// optional .google.protobuf.Duration min_latency = 2;
inline bool PrReceiverConfig::_internal_has_min_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_latency_ != nullptr);
  return value;
}
inline bool PrReceiverConfig::has_min_latency() const {
  return _internal_has_min_latency();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::_internal_min_latency() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.min_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::min_latency() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.min_latency)
  return _internal_min_latency();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_min_latency(
    ::PROTOBUF_NAMESPACE_ID::Duration* min_latency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_latency_);
  }
  _impl_.min_latency_ = min_latency;
  if (min_latency) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.min_latency)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::release_min_latency() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.min_latency_;
  _impl_.min_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::unsafe_arena_release_min_latency() {
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.min_latency)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.min_latency_;
  _impl_.min_latency_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::_internal_mutable_min_latency() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.min_latency_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.min_latency_ = p;
  }
  return _impl_.min_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::mutable_min_latency() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_min_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.min_latency)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_min_latency(::PROTOBUF_NAMESPACE_ID::Duration* min_latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_latency_);
  }
  if (min_latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_latency));
    if (message_arena != submessage_arena) {
      min_latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_latency, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.min_latency_ = min_latency;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.min_latency)
}

// optional .google.protobuf.Duration max_latency = 3;
inline bool PrReceiverConfig::_internal_has_max_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_latency_ != nullptr);
  return value;
}
inline bool PrReceiverConfig::has_max_latency() const {
  return _internal_has_max_latency();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::_internal_max_latency() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.max_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::max_latency() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.max_latency)
  return _internal_max_latency();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_max_latency(
    ::PROTOBUF_NAMESPACE_ID::Duration* max_latency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_latency_);
  }
  _impl_.max_latency_ = max_latency;
  if (max_latency) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.max_latency)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::release_max_latency() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.max_latency_;
  _impl_.max_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::unsafe_arena_release_max_latency() {
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.max_latency)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.max_latency_;
  _impl_.max_latency_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::_internal_mutable_max_latency() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.max_latency_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.max_latency_ = p;
  }
  return _impl_.max_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::mutable_max_latency() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_max_latency();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.max_latency)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_max_latency(::PROTOBUF_NAMESPACE_ID::Duration* max_latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_latency_);
  }
  if (max_latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_latency));
    if (message_arena != submessage_arena) {
      max_latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_latency, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.max_latency_ = max_latency;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.max_latency)
}

// optional .rocvad.PrLatencyTunerBackend latency_tuner_backend = 4;
inline bool PrReceiverConfig::_internal_has_latency_tuner_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PrReceiverConfig::has_latency_tuner_backend() const {
  return _internal_has_latency_tuner_backend();
}
inline void PrReceiverConfig::clear_latency_tuner_backend() {
  _impl_.latency_tuner_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::rocvad::PrLatencyTunerBackend PrReceiverConfig::_internal_latency_tuner_backend() const {
  return static_cast< ::rocvad::PrLatencyTunerBackend >(_impl_.latency_tuner_backend_);
}
inline ::rocvad::PrLatencyTunerBackend PrReceiverConfig::latency_tuner_backend() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.latency_tuner_backend)
  return _internal_latency_tuner_backend();
}
inline void PrReceiverConfig::_internal_set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.latency_tuner_backend_ = value;
}
inline void PrReceiverConfig::set_latency_tuner_backend(::rocvad::PrLatencyTunerBackend value) {
  _internal_set_latency_tuner_backend(value);
  // @@protoc_insertion_point(field_set:rocvad.PrReceiverConfig.latency_tuner_backend)
}

// optional .rocvad.PrLatencyTunerProfile latency_tuner_profile = 5;
inline bool PrReceiverConfig::_internal_has_latency_tuner_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PrReceiverConfig::has_latency_tuner_profile() const {
  return _internal_has_latency_tuner_profile();
}
inline void PrReceiverConfig::clear_latency_tuner_profile() {
  _impl_.latency_tuner_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::rocvad::PrLatencyTunerProfile PrReceiverConfig::_internal_latency_tuner_profile() const {
  return static_cast< ::rocvad::PrLatencyTunerProfile >(_impl_.latency_tuner_profile_);
}
inline ::rocvad::PrLatencyTunerProfile PrReceiverConfig::latency_tuner_profile() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.latency_tuner_profile)
  return _internal_latency_tuner_profile();
}
inline void PrReceiverConfig::_internal_set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.latency_tuner_profile_ = value;
}
inline void PrReceiverConfig::set_latency_tuner_profile(::rocvad::PrLatencyTunerProfile value) {
  _internal_set_latency_tuner_profile(value);
  // @@protoc_insertion_point(field_set:rocvad.PrReceiverConfig.latency_tuner_profile)
}

// optional .rocvad.PrResamplerBackend resampler_backend = 6;
inline bool PrReceiverConfig::_internal_has_resampler_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PrReceiverConfig::has_resampler_backend() const {
  return _internal_has_resampler_backend();
}
inline void PrReceiverConfig::clear_resampler_backend() {
  _impl_.resampler_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::rocvad::PrResamplerBackend PrReceiverConfig::_internal_resampler_backend() const {
  return static_cast< ::rocvad::PrResamplerBackend >(_impl_.resampler_backend_);
}
inline ::rocvad::PrResamplerBackend PrReceiverConfig::resampler_backend() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.resampler_backend)
  return _internal_resampler_backend();
}
inline void PrReceiverConfig::_internal_set_resampler_backend(::rocvad::PrResamplerBackend value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.resampler_backend_ = value;
}
inline void PrReceiverConfig::set_resampler_backend(::rocvad::PrResamplerBackend value) {
  _internal_set_resampler_backend(value);
  // @@protoc_insertion_point(field_set:rocvad.PrReceiverConfig.resampler_backend)
}

// optional .rocvad.PrResamplerProfile resampler_profile = 7;
inline bool PrReceiverConfig::_internal_has_resampler_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PrReceiverConfig::has_resampler_profile() const {
  return _internal_has_resampler_profile();
}
inline void PrReceiverConfig::clear_resampler_profile() {
  _impl_.resampler_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::rocvad::PrResamplerProfile PrReceiverConfig::_internal_resampler_profile() const {
  return static_cast< ::rocvad::PrResamplerProfile >(_impl_.resampler_profile_);
}
inline ::rocvad::PrResamplerProfile PrReceiverConfig::resampler_profile() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.resampler_profile)
  return _internal_resampler_profile();
}
inline void PrReceiverConfig::_internal_set_resampler_profile(::rocvad::PrResamplerProfile value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.resampler_profile_ = value;
}
inline void PrReceiverConfig::set_resampler_profile(::rocvad::PrResamplerProfile value) {
  _internal_set_resampler_profile(value);
  // @@protoc_insertion_point(field_set:rocvad.PrReceiverConfig.resampler_profile)
}

// optional .google.protobuf.Duration no_playback_timeout = 8;
inline bool PrReceiverConfig::_internal_has_no_playback_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.no_playback_timeout_ != nullptr);
  return value;
}
inline bool PrReceiverConfig::has_no_playback_timeout() const {
  return _internal_has_no_playback_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::_internal_no_playback_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.no_playback_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::no_playback_timeout() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.no_playback_timeout)
  return _internal_no_playback_timeout();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_no_playback_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* no_playback_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.no_playback_timeout_);
  }
  _impl_.no_playback_timeout_ = no_playback_timeout;
  if (no_playback_timeout) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.no_playback_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::release_no_playback_timeout() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.no_playback_timeout_;
  _impl_.no_playback_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::unsafe_arena_release_no_playback_timeout() {
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.no_playback_timeout)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.no_playback_timeout_;
  _impl_.no_playback_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::_internal_mutable_no_playback_timeout() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.no_playback_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.no_playback_timeout_ = p;
  }
  return _impl_.no_playback_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::mutable_no_playback_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_no_playback_timeout();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.no_playback_timeout)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_no_playback_timeout(::PROTOBUF_NAMESPACE_ID::Duration* no_playback_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.no_playback_timeout_);
  }
  if (no_playback_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(no_playback_timeout));
    if (message_arena != submessage_arena) {
      no_playback_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, no_playback_timeout, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.no_playback_timeout_ = no_playback_timeout;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.no_playback_timeout)
}

// optional .google.protobuf.Duration choppy_playback_timeout = 9;
inline bool PrReceiverConfig::_internal_has_choppy_playback_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.choppy_playback_timeout_ != nullptr);
  return value;
}
inline bool PrReceiverConfig::has_choppy_playback_timeout() const {
  return _internal_has_choppy_playback_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::_internal_choppy_playback_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.choppy_playback_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PrReceiverConfig::choppy_playback_timeout() const {
  // @@protoc_insertion_point(field_get:rocvad.PrReceiverConfig.choppy_playback_timeout)
  return _internal_choppy_playback_timeout();
}
inline void PrReceiverConfig::unsafe_arena_set_allocated_choppy_playback_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* choppy_playback_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.choppy_playback_timeout_);
  }
  _impl_.choppy_playback_timeout_ = choppy_playback_timeout;
  if (choppy_playback_timeout) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocvad.PrReceiverConfig.choppy_playback_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::release_choppy_playback_timeout() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.choppy_playback_timeout_;
  _impl_.choppy_playback_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::unsafe_arena_release_choppy_playback_timeout() {
  // @@protoc_insertion_point(field_release:rocvad.PrReceiverConfig.choppy_playback_timeout)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.choppy_playback_timeout_;
  _impl_.choppy_playback_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::_internal_mutable_choppy_playback_timeout() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.choppy_playback_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.choppy_playback_timeout_ = p;
  }
  return _impl_.choppy_playback_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PrReceiverConfig::mutable_choppy_playback_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_choppy_playback_timeout();
  // @@protoc_insertion_point(field_mutable:rocvad.PrReceiverConfig.choppy_playback_timeout)
  return _msg;
}
inline void PrReceiverConfig::set_allocated_choppy_playback_timeout(::PROTOBUF_NAMESPACE_ID::Duration* choppy_playback_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.choppy_playback_timeout_);
  }
  if (choppy_playback_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(choppy_playback_timeout));
    if (message_arena != submessage_arena) {
      choppy_playback_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, choppy_playback_timeout, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.choppy_playback_timeout_ = choppy_playback_timeout;
  // @@protoc_insertion_point(field_set_allocated:rocvad.PrReceiverConfig.choppy_playback_timeout)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rocvad

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rocvad::PrLogEntry_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrLogEntry_Level>() {
  return ::rocvad::PrLogEntry_Level_descriptor();
}
template <> struct is_proto_enum< ::rocvad::PrDeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrDeviceType>() {
  return ::rocvad::PrDeviceType_descriptor();
}
template <> struct is_proto_enum< ::rocvad::PrInterface> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrInterface>() {
  return ::rocvad::PrInterface_descriptor();
}
template <> struct is_proto_enum< ::rocvad::PrChannelLayout> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrChannelLayout>() {
  return ::rocvad::PrChannelLayout_descriptor();
}
template <> struct is_proto_enum< ::rocvad::PrPacketEncoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrPacketEncoding>() {
  return ::rocvad::PrPacketEncoding_descriptor();
}
template <> struct is_proto_enum< ::rocvad::PrFecEncoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrFecEncoding>() {
  return ::rocvad::PrFecEncoding_descriptor();
}
template <> struct is_proto_enum< ::rocvad::PrLatencyTunerBackend> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrLatencyTunerBackend>() {
  return ::rocvad::PrLatencyTunerBackend_descriptor();
}
template <> struct is_proto_enum< ::rocvad::PrLatencyTunerProfile> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrLatencyTunerProfile>() {
  return ::rocvad::PrLatencyTunerProfile_descriptor();
}
template <> struct is_proto_enum< ::rocvad::PrResamplerBackend> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrResamplerBackend>() {
  return ::rocvad::PrResamplerBackend_descriptor();
}
template <> struct is_proto_enum< ::rocvad::PrResamplerProfile> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocvad::PrResamplerProfile>() {
  return ::rocvad::PrResamplerProfile_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_driver_5fprotocol_2eproto
